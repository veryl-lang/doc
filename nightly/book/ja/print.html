<!DOCTYPE HTML>
<html lang="ja" class="light sidebar-visible" dir="ltr">
    <head prefix="og: http://ogp.me/ns#">
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Veryl Hardware Description Language</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        <!-- Google tag (gtag.js) -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-NXW2P6CCF3"></script>
        <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
        
            gtag('config', 'G-NXW2P6CCF3');
        </script>
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
                    let base = "https://doc.veryl-lang.org/book";
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/print.md`;
                    } else {
                        canonical_href = `${base}/${lang}/print.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ja");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
                const langs = ["en", "ja"];
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        
        <meta property="og:url" content="https://github.com/veryl-lang/veryl" />
        <meta property="og:title" content="Veryl: A Modern Hardware Description Language" />
        <meta property="og:description" content="Veryl is a hardware description language which is designed as a SystemVerilog alternative." />
        <meta property="og:image" content="https://github.com/veryl-lang/veryl/raw/master/support/logo/veryl_ogp.png" />

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/css/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Veryl Hardware Description Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="ハードウェア記述言語-veryl"><a class="header" href="#ハードウェア記述言語-veryl">ハードウェア記述言語 Veryl</a></h1>
<p><img src="https://github.com/veryl-lang/veryl/raw/master/support/logo/veryl_wide.png" alt="Veryl" /></p>
<p>Veryl は SystemVerilog をベースに設計されたハードウェア記述言語であり、以下のような特徴があります。</p>
<h2 id="最適化された構文"><a class="header" href="#最適化された構文">最適化された構文</a></h2>
<p>Verylは、SystemVerilogの経験者にとって親しみやすい基本構文に基づきながら、論理設計に最適化された構文を採用しています。この最適化には、たとえば合成可能性の保証やシミュレーション結果の一致の保証、頻出する定型文を簡素化する多数の構文などの提供が含まれます。このアプローチにより、学習の容易さ、設計プロセスの信頼性と効率の向上、およびコードの記述の容易さが実現されます。</p>
<h2 id="相互運用性"><a class="header" href="#相互運用性">相互運用性</a></h2>
<p>VerylはSystemVerilogとの相互運用性を考慮して設計されており、既存のSystemVerilogコンポーネントやプロジェクトとの組み合わせや部分的な置き換えをスムーズに行うことができます。さらに、VerylからトランスパイルされたSystemVerilogソースコードは、その高い可読性により、シームレスな統合やデバッグを可能にします。</p>
<h2 id="生産性"><a class="header" href="#生産性">生産性</a></h2>
<p>Verylはパッケージマネージャ、ビルドツール、そしてVSCode、Vim、Emacsなどの主要なエディタに対応するリアルタイムチェッカー、自動補完機能、自動フォーマッタなど、豊富な開発支援ツールを備えています。これらのツールは、開発プロセスを加速し、生産性を大幅に向上させることができます。</p>
<p>これらの特性により、Verylは設計者が高品質なハードウェア設計をより効率的かつ生産的に行うための強力なサポートを提供します。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="特徴"><a class="header" href="#特徴">特徴</a></h1>
<p>この章ではVerylの特徴的な機能をわかりやすい例とともに紹介します。</p>
<ul>
<li><a href="02_features.html#real-time-diagnostics">リアルタイム診断</a></li>
<li><a href="02_features.html#auto-formatting">自動フォーマット</a></li>
<li><a href="02_features.html#integrated-test">組み込みテスト</a></li>
<li><a href="02_features.html#dependency-management">依存関係管理</a></li>
<li><a href="02_features.html#generics">ジェネリクス</a></li>
<li><a href="02_features.html#clock-domain-annotation">クロックドメインアノテーション</a></li>
<li><a href="02_features.html#trailing-comma">末尾カンマ</a></li>
<li><a href="02_features.html#abstraction-of-clock-and-reset">クロックとリセットの抽象化</a></li>
<li><a href="02_features.html#documentation-comment">ドキュメンテーションコメント</a></li>
<li><a href="02_features.html#compound-assignment-operator-in-always_ff"><code>always_ff</code> での複合代入演算子</a></li>
<li><a href="02_features.html#individual-namespace-of-enum-variant">独立した名前空間を持つenumバリアント</a></li>
<li><a href="02_features.html#repeat-of-concatenation">ビット連結における <code>repeat</code></a></li>
<li><a href="02_features.html#if--case-expression"><code>if</code> / <code>case</code> 式</a></li>
<li><a href="02_features.html#range-based-for--inside--outside">範囲 <code>for</code> / <code>inside</code> / <code>outside</code></a></li>
<li><a href="02_features.html#msb-notation"><code>msb</code> 記法</a></li>
<li><a href="02_features.html#let-statement"><code>let</code> 文</a></li>
<li><a href="02_features.html#connect-operator"><code>&lt;&gt;</code> 演算子</a></li>
<li><a href="02_features.html#named-block">名前付きブロック</a></li>
<li><a href="02_features.html#visibility-control">可視性制御</a></li>
</ul>
<h2 id="real-time-diagnostics"><a class="header" href="#real-time-diagnostics">リアルタイム診断</a></h2>
<p>変数の未定義・未使用・未代入といった問題はエディタでの編集中にリアルタイムに通知されます。次の例では、未使用変数として通知された変数に <code>_</code> プレフィックスを付加することで未使用であることを明示し、警告を抑制しています。</p>
<video src="./img/diagnostics.mp4" autoplay loop muted>
</video>
<h2 id="auto-formatting"><a class="header" href="#auto-formatting">自動フォーマット</a></h2>
<p>エディタと連携した自動フォーマット機能のほか、コマンドラインでのフォーマットやCIでのフォーマットチェックも可能です。</p>
<video src="./img/format.mp4" autoplay loop muted>
</video>
<h2 id="integrated-test"><a class="header" href="#integrated-test">組み込みテスト</a></h2>
<p>SystemVerilogまたは<a href="https://www.cocotb.org">cocotb</a>で書かれたテストコードをVerylに埋め込み、<code>veryl test</code> コマンドで実行することができます。</p>
<pre><code class="language-veryl">#[test(test1)]
embed (inline) sv{{{
    module test1;
        initial begin
            assert (0) else $error("error");
        end
    endmodule
}}}
</code></pre>
<h2 id="dependency-management"><a class="header" href="#dependency-management">依存関係管理</a></h2>
<p>Verylには依存関係の管理機能が組み込まれており、プロジェクト設定に以下のようにライブラリのリポジトリパスとバージョンを追加するだけで、簡単にライブラリを組み込むことができます。</p>
<pre><code class="language-toml">[dependencies]
veryl_sample = {git = "https://github.com/veryl-lang/veryl_sample", version = "0.1.0"}
</code></pre>
<h2 id="generics"><a class="header" href="#generics">ジェネリクス</a></h2>
<p>ジェネリクスによるコード生成は従来のパラメータオーバーライドよりさらに再利用性の高いコードを記述することができます。以下の例のような関数のパラメータだけでなく、インスタンスのモジュール名や構造体定義の型名もパラメータ化することができます。</p>
<table>
<tr>
<th>SystemVerilog</th>
<th>Veryl</th>
</tr>
<tr>
<td>
<pre><code class="language-verilog">function automatic logic [20-1:0] FuncA_20 (
    input logic [20-1:0] a
);
    return a + 1;
endfunction

function automatic logic [10-1:0] FuncA_10 (
    input logic [10-1:0] a
);
    return a + 1;
endfunction

logic [10-1:0] a;
logic [20-1:0] b;
always_comb begin
    a = FuncA_10(1);
    b = FuncA_20(1);
end
</code></pre>
</td>
<td>
<pre><code class="language-veryl">function FuncA::&lt;T: u32&gt; (
    a: input logic&lt;T&gt;,
) -&gt; logic&lt;T&gt; {
    return a + 1;
}

var a: logic&lt;10&gt;;
var b: logic&lt;10&gt;;
always_comb {
    a = FuncA::&lt;10&gt;(1);
    b = FuncA::&lt;20&gt;(1);
}
</code></pre>
</td>
</tr>
</table>
<h2 id="clock-domain-annotation"><a class="header" href="#clock-domain-annotation">クロックドメインアノテーション</a></h2>
<p>モジュール内に複数のクロックがある場合、明示的なクロックドメインアノテーションとクロックドメイン境界への <code>unsafe (cdc)</code> ブロックが必要です。Veryl コンパイラは意図しないクロックドメインクロッシングをエラーとして検出し、明示的な <code>unsafe (cdc)</code> ブロックによりレビューが容易になります。</p>
<table>
<tr>
<th>SystemVerilog</th>
<th>Veryl</th>
</tr>
<tr>
<td>
<pre><code class="language-verilog">module ModuleA (
    input  i_clk_a,
    input  i_dat_a,
    output o_dat_a,
    input  i_clk_b,
    input  i_dat_b,
    output o_dat_b
);
    // 注意!!!
    // i_clk_a から i_clk_b へ
    assign o_dat_b = i_dat_a;
endmodule
</code></pre>
</td>
<td>
<pre><code class="language-veryl">module ModuleA (
    i_clk_a: input  'a clock,
    i_dat_a: input  'a logic,
    i_dat_a: output 'a logic,
    i_clk_b: input  'b clock,
    i_dat_b: input  'b logic,
    i_dat_b: output 'b logic,
) {
    unsafe (cdc) {
        assign o_dat_b = i_dat_a;
    }
}
</code></pre>
</td>
</tr>
</table>
<h2 id="trailing-comma"><a class="header" href="#trailing-comma">末尾カンマ</a></h2>
<p>末尾カンマは、リストの最後の要素の後ろにカンマが置かれる構文です。これにより、要素の追加や削除が容易になり、バージョン管理システムにおける不必要な差異を減らすことができます。</p>
<table>
<tr>
<th>SystemVerilog</th>
<th>Veryl</th>
</tr>
<tr>
<td>
<pre><code class="language-verilog">module ModuleA (
    input  a,
    input  b,
    output o
);
endmodule
</code></pre>
</td>
<td>
<pre><code class="language-veryl">module ModuleA (
    a: input  logic,
    b: input  logic,
    o: output logic,
) {
}
</code></pre>
</td>
</tr>
</table>
<h2 id="abstraction-of-clock-and-reset"><a class="header" href="#abstraction-of-clock-and-reset">クロックとリセットの抽象化</a></h2>
<p>クロックの極性やリセットの極性と同期性を構文上指定する必要はなく、ビルド時の設定で指定することができます。これにより同じVerylのコードからASIC向けの負極性・非同期リセットとFPGA向けの正極性・同期リセットのそれぞれのコードを生成することができます。</p>
<p>さらに、明示的な <code>clock</code> と <code>reset</code> 型により、レジスタへのクロック・リセット接続が正しく行われているかどうかを確認することができます。モジュール内にクロックとリセットが1つだけの場合、レジスタへの接続を省略することもできます。</p>
<table>
<tr>
<th>SystemVerilog</th>
<th>Veryl</th>
</tr>
<tr>
<td>
<pre><code class="language-verilog">module ModuleA (
    input logic i_clk,
    input logic i_rst_n
);

always_ff @ (posedge i_clk or negedge i_rst_n) begin
    if (!i_rst_n) begin
    end else begin
    end
end

endmodule
</code></pre>
</td>
<td>
<pre><code class="language-veryl">module ModuleA (
    i_clk: input clock,
    i_rst: input reset,
){
    always_ff {
        if_reset {
        } else {
        }
    }
}
</code></pre>
</td>
</tr>
</table>
<h2 id="documentation-comment"><a class="header" href="#documentation-comment">ドキュメンテーションコメント</a></h2>
<p>ドキュメンテーションコメントとしてモジュールの説明を書いておくとドキュメントを自動生成することができます。単なるテキストだけでなく、以下のフォーマットを使用することができます。</p>
<ul>
<li><a href="https://www.markdownguide.org">Markdown</a></li>
<li><a href="https://wavedrom.com">WaveDrom</a>による波形記述</li>
<li><a href="https://mermaid.js.org">Mermaid</a>によるダイアグラム記述</li>
</ul>
<table>
<tr>
<th>SystemVerilog</th>
<th>Veryl</th>
</tr>
<tr>
<td>
<pre><code class="language-verilog">// コメント
module ModuleA;
endmodule
</code></pre>
</td>
<td>
<pre><code class="language-veryl">/// マークダウン形式のドキュメンテーションコメント
///
/// * リスト
/// * リスト
///
/// ```wavedrom
/// { signal: [{ name: "Alfa", wave: "01.zx=ud.23.456789" }] }
/// ```
module ModuleA {
}
</code></pre>
</td>
</tr>
</table>
<h2 id="compound-assignment-operator-in-always_ff"><a class="header" href="#compound-assignment-operator-in-always_ff"><code>always_ff</code> での複合代入演算子</a></h2>
<p>ノンブロッキング専用の代入演算子はなく、<code>always_ff</code> 内ではノンブロッキング代入が、 <code>always_comb</code> 内ではブロッキング代入が推論されます。そのため <code>always_ff</code> 内でも <code>always_comb</code> 内と同様に様々な複合代入演算子を使用することができます。</p>
<table>
<tr>
<th>SystemVerilog</th>
<th>Veryl</th>
</tr>
<tr>
<td>
<pre><code class="language-verilog">always_ff @ (posedge i_clk) begin
    if (a) begin
        x &lt;= x + 1;
    end
end
</code></pre>
</td>
<td>
<pre><code class="language-veryl">always_ff {
    if a {
        x += 1;
    }
}
</code></pre>
</td>
</tr>
</table>
<h2 id="individual-namespace-of-enum-variant"><a class="header" href="#individual-namespace-of-enum-variant">独立した名前空間を持つenumバリアント</a></h2>
<p>enumのバリアントはenum毎に独立した名前空間を持っており意図しない名前の衝突を防ぐことができます。</p>
<table>
<tr>
<th>SystemVerilog</th>
<th>Veryl</th>
</tr>
<tr>
<td>
<pre><code class="language-verilog">typedef enum logic[1:0] {
    MemberA,
    MemberB
} EnumA;

EnumA a;
assign a = MemberA;
</code></pre>
</td>
<td>
<pre><code class="language-veryl">enum EnumA: logic&lt;2&gt; {
    MemberA,
    MemberB
}

var a: EnumA;
assign a = EnumA::MemberA;
</code></pre>
</td>
</tr>
</table>
<h2 id="repeat-of-concatenation"><a class="header" href="#repeat-of-concatenation">ビット連結における <code>repeat</code></a></h2>
<p>ビット連結における繰り返し記述として明示的な <code>repeat</code> 記法を採用し、 複雑な <code>{}</code> の組み合わせより可読性が向上しています。</p>
<table>
<tr>
<th>SystemVerilog</th>
<th>Veryl</th>
</tr>
<tr>
<td>
<pre><code class="language-verilog">logic [31:0] a;
assign a = {{2{X[9:0]}}, {12{Y}}};
</code></pre>
</td>
<td>
<pre><code class="language-veryl">var a: logic&lt;32&gt;;
assign a = {X[9:0] repeat 2, Y repeat 12};
</code></pre>
</td>
</tr>
</table>
<h2 id="if--case-expression"><a class="header" href="#if--case-expression"><code>if</code> / <code>case</code> 式</a></h2>
<p>三項演算子の代わりに if 式と case 式を採用することで、比較するアイテム数が多い場合の可読性が向上します。</p>
<table>
<tr>
<th>SystemVerilog</th>
<th>Veryl</th>
</tr>
<tr>
<td>
<pre><code class="language-verilog">logic a;
assign a = X == 0 ? Y0 :
           X == 1 ? Y1 :
           X == 2 ? Y2 :
                    Y3;
</code></pre>
</td>
<td>
<pre><code class="language-veryl">var a: logic;
assign a = case X {
    0      : Y0,
    1      : Y1,
    2      : Y2,
    default: Y3,
};
</code></pre>
</td>
</tr>
</table>
<h2 id="range-based-for--inside--outside"><a class="header" href="#range-based-for--inside--outside">範囲 <code>for</code> / <code>inside</code> / <code>outside</code></a></h2>
<p>閉区間 <code>..=</code> と半開区間 <code>..</code> を表す記法を導入し、 <code>for</code> 、<code>inside</code> で範囲を統一的に記述できるようにしました。また、<code>inside</code> の逆を意味する <code>outside</code> も導入しました。</p>
<table>
<tr>
<th>SystemVerilog</th>
<th>Veryl</th>
</tr>
<tr>
<td>
<pre><code class="language-verilog">for (int i = 0; i &lt; 10; i++) begin
    a[i] =   X[i] inside {[1:10]};
    b[i] = !(X[i] inside {[1:10]});
end
</code></pre>
</td>
<td>
<pre><code class="language-veryl">for i: u32 in 0..10 {
    a[i] = inside  X[i] {1..=10};
    b[i] = outside X[i] {1..=10};
}
</code></pre>
</td>
</tr>
</table>
<h2 id="msb-notation"><a class="header" href="#msb-notation"><code>msb</code> 記法</a></h2>
<p>最上位ビットを示す <code>msb</code> 記法により、パラメータから最上位ビットを計算する必要がなくなり、より意図を明確にすることができます。</p>
<table>
<tr>
<th>SystemVerilog</th>
<th>Veryl</th>
</tr>
<tr>
<td>
<pre><code class="language-verilog">logic a;
logic [WIDTH-1:0] X;
assign a = X[WIDTH-1];
</code></pre>
</td>
<td>
<pre><code class="language-veryl">var a: logic;
var X: logic&lt;WIDTH&gt;;
assign a = X[msb];
</code></pre>
</td>
</tr>
</table>
<h2 id="let-statement"><a class="header" href="#let-statement"><code>let</code> 文</a></h2>
<p>変数宣言と同時に値を束縛する専用の <code>let</code> 文が用意されており、SystemVerilogではサポートされていなかった様々な場所で使用することができます。</p>
<table>
<tr>
<th>SystemVerilog</th>
<th>Veryl</th>
</tr>
<tr>
<td>
<pre><code class="language-verilog">logic tmp;
always_ff @ (posedge i_clk) begin
    tmp = b + 1;
    x &lt;= tmp;
end
</code></pre>
</td>
<td>
<pre><code class="language-veryl">always_ff {
    let tmp: logic = b + 1;
    x = tmp;
}
</code></pre>
</td>
</tr>
</table>
<h2 id="connect-operator"><a class="header" href="#connect-operator"><code>&lt;&gt;</code> 演算子</a></h2>
<p><code>&lt;&gt;</code> 演算子は2つのインターフェースを接続します。SystemVerilogではインターフェースを接続するためにぞれぞれのメンバーを代入する必要がありましたが、簡単に接続することができるようになります。</p>
<table>
<tr>
<th>SystemVerilog</th>
<th>Veryl</th>
</tr>
<tr>
<td>
<pre><code class="language-verilog">always_comb begin
    mst_if0.cmd   = bus_if0.cmd;
    bus_if0.ready = mst_if0.ready;
end

always_comb begin
    mst_if1.cmd   = bus_if1.cmd;
    bus_if1.ready = mst_if1.ready;
end
</code></pre>
</td>
<td>
<pre><code class="language-veryl">connect mst_if0 &lt;&gt; bus_if0.slave;

always_comb {
    mst_if1 &lt;&gt; bus_if1.slave;
}
</code></pre>
</td>
</tr>
</table>
<h2 id="named-block"><a class="header" href="#named-block">名前付きブロック</a></h2>
<p>変数のスコープを限定するための名前付きブロックを定義することができます。</p>
<table>
<tr>
<th>SystemVerilog</th>
<th>Veryl</th>
</tr>
<tr>
<td>
<pre><code class="language-verilog">if (1) begin: BlockA
end
</code></pre>
</td>
<td>
<pre><code class="language-veryl">:BlockA {
}
</code></pre>
</td>
</tr>
</table>
<h2 id="visibility-control"><a class="header" href="#visibility-control">可視性制御</a></h2>
<p><code>pub</code> キーワードの付かないモジュールはプロジェクト外から参照できず、ドキュメントの自動生成にも含まれません。これによりプロジェクト外に公開したいものと内部実装とを区別することができます。</p>
<table>
<tr>
<th>SystemVerilog</th>
<th>Veryl</th>
</tr>
<tr>
<td>
<pre><code class="language-verilog">module ModuleA;
endmodule

module ModuleB;
endmodule
</code></pre>
</td>
<td>
<pre><code class="language-veryl">pub module ModuleA {
}

module ModuleB {
}
</code></pre>
</td>
</tr>
</table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="はじめに"><a class="header" href="#はじめに">はじめに</a></h1>
<p>Veryl を使ってみましょう。この章では Veryl のインストール、サンプルプロジェクトの作成とビルドまでを行います。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="インストール"><a class="header" href="#インストール">インストール</a></h1>
<p>Veryl は公式のツールチェーンインストーラ <code>verylup</code> を使ってインストールできます。ツールチェーンのアップデートなど便利な機能があるので <code>verylup</code> の使用を推奨します。</p>
<blockquote>
<p>注: インターネットアクセスのない環境にインストールしたい場合は <a href="03_getting_started/../06_development_environment/13_verylup.html#offline-installation">オフラインインストール</a> が利用できます。</p>
</blockquote>
<h2 id="要件"><a class="header" href="#要件">要件</a></h2>
<p>Veryl は <code>git</code> コマンドを内部で使用します。 <code>git</code> が起動できることを確認しておいてください。</p>
<h2 id="verylup-のインストール"><a class="header" href="#verylup-のインストール">verylup のインストール</a></h2>
<h3 id="バイナリのダウンロード"><a class="header" href="#バイナリのダウンロード">バイナリのダウンロード</a></h3>
<p><a href="https://github.com/veryl-lang/verylup/releases/latest">リリースページ</a>からダウンロードして、パスの通ったところに展開してください。</p>
<h3 id="cargo"><a class="header" href="#cargo">Cargo</a></h3>
<p><a href="https://crates.io/crates/verylup">cargo</a> コマンドからインストールすることもできます。</p>
<pre><code>cargo install verylup
</code></pre>
<h2 id="verylup-のセットアップ"><a class="header" href="#verylup-のセットアップ">verylup のセットアップ</a></h2>
<p>verylup をインストールした後、以下のコマンドを1回実行してください。最新のツールチェーンをダウンロードし、<code>veryl</code> と <code>veryl-ls</code> コマンドをverylupと同じ場所に作成します。</p>
<pre><code>verylup setup
</code></pre>
<p>これで <code>veryl</code> コマンドが使えるようになりました。</p>
<h2 id="エディタ設定"><a class="header" href="#エディタ設定">エディタ設定</a></h2>
<p>公式には <a href="https://azure.microsoft.com/ja-jp/products/visual-studio-code">Visual Studio Code</a> と <a href="https://github.com/vim/vim">Vim</a> / <a href="https://neovim.io">Neovim</a> がサポートされています。</p>
<h3 id="visual-studio-code"><a class="header" href="#visual-studio-code">Visual Studio Code</a></h3>
<p>Visual Studio Code 向けに Veryl 拡張が提供されています。拡張はファイルタイプの検出とシンタックスハイライト、言語サーバの組み込みを提供します。拡張パネルから “Veryl” で検索するか、以下の URL からインストールしてください。</p>
<p><a href="https://marketplace.visualstudio.com/items?itemName=dalance.vscode-veryl">Veryl extension for Visual Studio Code</a></p>
<h3 id="vim--neovim"><a class="header" href="#vim--neovim">Vim / Neovim</a></h3>
<p>Vim / Neovim 向けに Veryl プラグインが提供されています。プラグインはファイルタイプの検出とシンタックスハイライトを提供します。プラグインのインストールと言語サーバの組み込みは以下の URL を参照してください。</p>
<p><a href="https://github.com/veryl-lang/veryl.vim">Vim / Neovim plugin</a></p>
<h3 id="zed"><a class="header" href="#zed">Zed</a></h3>
<p><a href="https://zed.dev/">Zed</a> 向けに Veryl 拡張が提供されています。拡張はファイルタイプの検出とシンタックスハイライト、言語サーバの組み込みを提供します。拡張パネルから “Veryl” で検索するか、以下の URL からインストールしてください。</p>
<p><a href="https://zed.dev/extensions/veryl">Veryl extension for Zed</a></p>
<h3 id="そのほかのエディタ"><a class="header" href="#そのほかのエディタ">そのほかのエディタ</a></h3>
<p>Veryl は言語サーバを提供しているので、言語サーバをサポートしているエディタ（例えば Emacs）であれば利用できます。</p>
<h2 id="シェル補完"><a class="header" href="#シェル補完">シェル補完</a></h2>
<p><code>veryl</code> と <code>verylup</code> のシェル補完スクリプトは <code>verylup completion</code> によって提供されます。例えば以下のコマンドはzsh向けの補完スクリプトを生成します。</p>
<pre><code>verylup completion zsh veryl   &gt; _veryl
verylup completion zsh verylup &gt; _verylup
</code></pre>
<p>サポートされているシェルは以下の通りです。</p>
<ul>
<li>Bash</li>
<li>Elvish</li>
<li>Fish</li>
<li>PowerShell</li>
<li>Zsh</li>
</ul>
<p>生成されたスクリプトの使い方は各シェルのドキュメントを参照してください。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-world"><a class="header" href="#hello-world">Hello, World!</a></h1>
<h2 id="プロジェクトを作る"><a class="header" href="#プロジェクトを作る">プロジェクトを作る</a></h2>
<p>まず始めに、新しい Veryl プロジェクトを作りましょう。</p>
<pre><code>veryl new hello
</code></pre>
<p>コマンドを実行すると、以下のディレクトリとファイルが作成されます。もし <code>git</code> コマンドが利用できれば、ディレクトリは Git リポジトリとして初期化され、デフォルトの <code>.gitignore</code> ファイルも追加されます。</p>
<pre><code>$ veryl new hello
[INFO ]      Created "hello" project
$ cd hello
$ tree
.
├── src
└── Veryl.toml

1 directory, 1 file
</code></pre>
<p><code>Veryl.toml</code> はプロジェクトの設定ファイルです。</p>
<pre><code class="language-toml">[project]
name = "hello"
version = "0.1.0"
[build]
source = "src"
target = {type = "directory", path = "target"}
</code></pre>
<p>全設定の説明は<a href="03_getting_started/../06_development_environment/01_project_configuration.html">こちら</a>。</p>
<h2 id="コードを書く"><a class="header" href="#コードを書く">コードを書く</a></h2>
<p>ソースコードはプロジェクトディレクトリ内のどこに書いても構いません。これは Veryl プロジェクトが独立したプロジェクトである場合もあれば、他のSystemVerilog プロジェクトに組み込まれている場合もあるからです。Veryl のソースコードの拡張子は <code>.veryl</code> です。</p>
<p>例えば以下のコードを <code>src/hello.veryl</code> に書いてみましょう。</p>
<pre><code class="language-veryl playground">module ModuleA {
    initial {
        $display("Hello, world!");
    }
}
</code></pre>
<pre><code>$ tree
.
├── src
│   └── hello.veryl
└── Veryl.toml

1 directory, 2 files
</code></pre>
<blockquote>
<p>注：この本のいくつかのソースコードには、マウスをホバーすると現れるプレイボタン “▶” があります。ボタンをクリックすると、トランスパイルされた SystemVerilog のコードが現れます。<code>module ModuleA</code> のコードのボタンを押してみましょう。</p>
</blockquote>
<h2 id="ビルドする"><a class="header" href="#ビルドする">ビルドする</a></h2>
<p><code>veryl build</code> コマンドで SystemVerilog のソースコードを生成できます。</p>
<pre><code>$ veryl build
[INFO ]   Processing file ([path to hello]/src/hello.veryl)
[INFO ]       Output filelist ([path to hello]/hello.f)
$ tree
.
├── dependencies
├── hello.f
├── src
│   └── hello.veryl
├── target
│   ├── hello.sv
│   └── hello.sv.map
├── Veryl.lock
└── Veryl.toml

3 directories, 6 files
</code></pre>
<p>デフォルトでは SystemVerilog のコードは Veryl のコードと同じディレクトリに生成されます。つまり <code>src/hello.sv</code> です。</p>
<pre><code class="language-verilog">module hello_ModuleA;
    initial begin
        $display("Hello, world!");
    end
endmodule
//# sourceMappingURL=hello.sv.map
</code></pre>
<p>さらに、生成されたコードのファイルリスト <code>hello.f</code> も生成されます。これは SystemVerilog コンパイラで使用できます。<a href="https://www.veripool.org/verilator/">Verilator</a> で使用するには以下のようにします。</p>
<pre><code>$ verilator --binary -f hello.f
</code></pre>
<h2 id="生成されたコードを片づける"><a class="header" href="#生成されたコードを片づける">生成されたコードを片づける</a></h2>
<p>生成されたコードは <code>veryl clean</code> コマンドで削除することができます。</p>
<pre><code>$ veryl clean
[INFO ]   Removing file ([path to hello]/src/hello.sv)
[INFO ]   Removing file ([path to hello]/src/hello.sv.map)
[INFO ]   Removing dir  ([path to hello]/dependencies)
[INFO ]   Removing file ([path to hello]/hello.f)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="コード例"><a class="header" href="#コード例">コード例</a></h1>
<p>Veryl は SystemVerilog とほとんど同じセマンティクスを持っています。もし SystemVerilog に慣れていれば、いくつかの例をみるだけで Veryl の構文をだいたい把握できるでしょう。</p>
<p>この小さな例では、コメントに SystemVerilog 構文との違いが書かれています。</p>
<pre><code class="language-veryl playground editable">module ModuleA (
    // 識別子が先で `:` の後に型が来ます
    // ビット幅は `&lt;&gt;` で表されます
    i_data: input  logic&lt;10&gt;,
    o_data: output logic&lt;10&gt;,

    // `begin`/`end` ではなく `{}` を使います
) {
    assign o_data = i_data;
}
</code></pre>
<p>さらに、この章のコードブロックは編集することもできます。それぞれのコードを編集して実行してみましょう。</p>
<p>Veryl のソースコードは SystemVerilog と同様に、<code>module</code>、<code>interface</code>、<code>package</code> を持ちます。この章ではそれらの例を示します。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="モジュール"><a class="header" href="#モジュール">モジュール</a></h1>
<pre><code class="language-veryl playground editable">// モジュール定義
module ModuleA #(
    param ParamA: u32 = 10,
    const ParamB: u32 = 10, // 末尾カンマが可能です
) (
    i_clk : input  clock            , // `clock` はクロックのための特別な型です
    i_rst : input  reset            , // `reset` はリセットのための特別な型です
    i_sel : input  logic            ,
    i_data: input  logic&lt;ParamA&gt; [2], // `[]` は SystemVerilog のアンパック配列です
    o_data: output logic&lt;ParamA&gt;    , // `&lt;&gt;` は SystemVerilog のパック配列です
) {
    // ローカルパラメータ宣言
    //   モジュール内では `param` は使えません
    const ParamC: u32 = 10;

    // 変数宣言
    var r_data0: logic&lt;ParamA&gt;;
    var r_data1: logic&lt;ParamA&gt;;
    var r_data2: logic&lt;ParamA&gt;;

    // 値の束縛
    let _w_data2: logic&lt;ParamA&gt; = i_data[0];

    // リセット付き always_ff 文
    //   `always_ff` はクロック（必須）とリセット（オプション）を持ちます
    //   `if_reset` は `if (i_rst)` を意味し、リセット極性を隠蔽するための構文です
    //   `if` 文に `()` はいりません
    //   `always_ff` 内の `=` はノンブロッキング代入です
    always_ff (i_clk, i_rst) {
        if_reset {
            r_data0 = 0;
        } else if i_sel {
            r_data0 = i_data[0];
        } else {
            r_data0 = i_data[1];
        }
    }

    // リセットなし always_ff 文
    always_ff (i_clk) {
        r_data1 = r_data0;
    }

    // モジュール内にクロックとリセットが1つしかない場合
    // クロックとリセットの指定は省略できます
    always_ff {
        r_data2 = r_data1;
    }

    assign o_data = r_data1;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="インスタンス"><a class="header" href="#インスタンス">インスタンス</a></h1>
<pre><code class="language-veryl playground editable">module ModuleA #(
    param ParamA: u32 = 10,
) (
    i_clk : input  clock        ,
    i_rst : input  reset        ,
    i_data: input  logic&lt;ParamA&gt;,
    o_data: output logic&lt;ParamA&gt;,
) {
    var r_data1: logic&lt;ParamA&gt;;
    var r_data2: logic&lt;ParamA&gt;;

    assign r_data1 = i_data + 1;
    assign o_data  = r_data2 + 2;

    // インスタンス宣言
    //   インスタンス宣言は `inst` キーワードではじまります
    //   ポート接続は `()` 内で指定します
    //   各ポートの接続は `[port_name]:[variable]` のような形式になります
    //   `[port_name]` は `[port_name]:[port_name]` を意味します
    inst u_module_b: ModuleB (
        i_clk          ,
        i_data: r_data1,
        o_data: r_data2,
    );

    // パラメータオーバーライド付きインスタンス宣言
    //   パラメータの接続記法はポートと同様です
    inst u_module_c: ModuleC #( ParamA, ParamB: 10 );
}

module ModuleB #(
    param ParamA: u32 = 10,
) (
    i_clk : input  clock        ,
    i_data: input  logic&lt;ParamA&gt;,
    o_data: output logic&lt;ParamA&gt;,
) {
    assign o_data = 1;
}

module ModuleC #(
    param ParamA: u32 = 10,
    param ParamB: u32 = 10,
) () {}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="インターフェース"><a class="header" href="#インターフェース">インターフェース</a></h1>
<pre><code class="language-veryl playground editable">// インターフェース定義
interface InterfaceA #(
    param ParamA: u32 = 1,
    param ParamB: u32 = 1,
) {
    const ParamC: u32 = 1;

    var a: logic&lt;ParamA&gt;;
    var b: logic&lt;ParamA&gt;;
    var c: logic&lt;ParamA&gt;;

    // modport 定義
    modport master {
        a: input ,
        b: input ,
        c: output,
    }

    modport slave {
        a: input ,
        b: input ,
        c: output,
    }
}

module ModuleA (
    i_clk: input clock,
    i_rst: input reset,
    // modport によるポート宣言
    intf_a_mst: modport InterfaceA::master,
    intf_a_slv: modport InterfaceA::slave ,
) {
    // インターフェースのインスタンス
    inst u_intf_a: InterfaceA [10];
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="パッケージ"><a class="header" href="#パッケージ">パッケージ</a></h1>
<pre><code class="language-veryl playground editable">// パッケージ定義
package PackageA {
    const ParamA: u32 = 1;
    const ParamB: u32 = 1;

    function FuncA (
        a: input logic&lt;ParamA&gt;,
    ) -&gt; logic&lt;ParamA&gt; {
        return a + 1;
    }
}

module ModuleA {
    let a : logic&lt;10&gt; = PackageA::ParamA;
    let _b: logic&lt;10&gt; = PackageA::FuncA(a);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="言語リファレンス"><a class="header" href="#言語リファレンス">言語リファレンス</a></h1>
<p>この章では Veryl の言語仕様について説明します。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ソースコードの構造"><a class="header" href="#ソースコードの構造">ソースコードの構造</a></h1>
<p>Veryl のソースコードはいくつかの <code>module</code>、<code>interface</code>、<code>package</code> からなります。</p>
<pre><code class="language-veryl playground">module ModuleA {}

module ModuleB {}

interface InterfaceA {}

package PackageA {}
</code></pre>
<p>トランスパイルされたコードにおける <code>module</code>、<code>interface</code>、<code>package</code> の名前には先頭にプロジェクト名が付きます。このサンプルコードでは <code>project_</code> が付きます。これはプロジェクト間で名前が衝突するのを防ぐためです。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="字句構造"><a class="header" href="#字句構造">字句構造</a></h1>
<p>この章では Veryl の字句構造について説明します。まず始めに、全体的なことがらからです。</p>
<h2 id="エンコーディング"><a class="header" href="#エンコーディング">エンコーディング</a></h2>
<p>Veryl のソースコードは UTF-8 エンコーディングでなければなりません。</p>
<h2 id="空白"><a class="header" href="#空白">空白</a></h2>
<p><code> </code>（空白）、<code>\t</code>、<code>\n</code> は空白として扱われ、Veryl のパーサはこれらを全て無視します。</p>
<h2 id="コメント"><a class="header" href="#コメント">コメント</a></h2>
<p>行コメントと複数行コメントが使えます。ほとんどのコメントはトランスパイルされたコードにも出力されます。</p>
<pre><code class="language-veryl playground">// 行コメント

/*
複数

行

コメント
*/

</code></pre>
<h3 id="ドキュメンテーションコメント"><a class="header" href="#ドキュメンテーションコメント">ドキュメンテーションコメント</a></h3>
<p><code>///</code> ではじまる行コメントはドキュメンテーションコメントとして扱われます。ドキュメンテーションコメントはドキュメントの生成に使われます。</p>
<pre><code class="language-veryl playground">/// ドキュメンテーションコメント

</code></pre>
<h2 id="識別子"><a class="header" href="#識別子">識別子</a></h2>
<p>識別子は ASCII のアルファベットと数値、 <code>_</code> からなります。先頭が数値であってはなりません。正式な定義は以下の正規表現です。</p>
<pre><code>[a-zA-Z_][a-zA-Z0-9_]*
</code></pre>
<h2 id="生識別子"><a class="header" href="#生識別子">生識別子</a></h2>
<p>Veryl のいくつかのキーワードは SystemVerilog では識別子として使用できるため、これらの識別子にアクセスするために生識別子を使います。例えば、<code>clock</code> は Veryl のキーワードなので <code>r#clock</code> とします。<code>r#clock</code> は SystemVerilog では <code>clock</code> にトランスパイルされます。</p>
<h2 id="文字列"><a class="header" href="#文字列">文字列</a></h2>
<p><code>"</code> で囲んだものが文字列になります。<code>\"</code> や <code>\n</code> のように <code>\</code> によるエスケープも可能です。</p>
<pre><code>"Hello, World!"
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="演算子"><a class="header" href="#演算子">演算子</a></h1>
<p>ほとんどの演算子は SystemVerilog と同じです。いくつか違いがあるので注意してください。</p>
<ul>
<li><code>&lt;:</code> 小なり演算子です。SystemVerilog の <code>&lt;</code> と同じです。</li>
<li><code>&gt;:</code> 大なり演算子です。SystemVerilog の <code>&gt;</code> と同じです。</li>
</ul>
<pre><code class="language-veryl">// 単項算術演算
a = +1;
a = -1;

// 単項論理演算
a = !1;
a = ~1;

// 単項集約演算
a = &amp;1;
a = |1;
a = ^1;
a = ~&amp;1;
a = ~|1;
a = ~^1;

// 二項算術演算
a = 1 ** 1;
a = 1 * 1;
a = 1 / 1;
a = 1 % 1;
a = 1 + 1;
a = 1 - 1;

// シフト演算
a = 1 &lt;&lt; 1;
a = 1 &gt;&gt; 1;
a = 1 &lt;&lt;&lt; 1;
a = 1 &gt;&gt;&gt; 1;

// 比較演算
a = 1 &lt;: 1;
a = 1 &lt;= 1;
a = 1 &gt;: 1;
a = 1 &gt;= 1;
a = 1 == 1;
a = 1 != 1;
a = 1 ==? 1;
a = 1 !=? 1;

// ビット演算
a = 1 &amp; 1;
a = 1 ^ 1;
a = 1 ~^ 1;
a = 1 | 1;

// 二項論理演算
a = 1 &amp;&amp; 1;
a = 1 || 1;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数値"><a class="header" href="#数値">数値</a></h1>
<h2 id="整数"><a class="header" href="#整数">整数</a></h2>
<pre><code class="language-veryl">// 整数
0123456789
01_23_45_67_89

// 2進数
32'b01xzXZ
32'b01_xz_XZ

// 8進数
36'o01234567xzXZ
36'o01_23_45_67_xz_XZ

// 10進数
32'd0123456789
32'd01_23_45_67_89

// 16進数
128'h0123456789abcdefxzABCDEFXZ
128'h01_23_45_67_89_ab_cd_ef_xz_AB_CD_EF_XZ
</code></pre>
<h2 id="全ビットのセット"><a class="header" href="#全ビットのセット">全ビットのセット</a></h2>
<pre><code class="language-veryl">// 全て 0
'0

// 全て 1
'1

// 全て x
'x
'X

// 全て z
'z
'Z
</code></pre>
<h2 id="幅なし整数"><a class="header" href="#幅なし整数">幅なし整数</a></h2>
<p>ビット幅指定は省略することができます。省略された場合、トランスパイルされたコードでは適切なビット幅が付与されます。</p>
<pre><code class="language-veryl playground">module ModuleA {
    const a0: u64 = 'b0101;
    const a1: u64 = 'o01234567;
    const a2: u64 = 'd0123456789;
    const a3: u64 = 'h0123456789fffff;
}
</code></pre>
<h2 id="指定ビットのセット"><a class="header" href="#指定ビットのセット">指定ビットのセット</a></h2>
<p>“全ビットのセット” にビット幅指定を付与することもできます。</p>
<pre><code class="language-veryl playground">module ModuleA {
    const a0: logic&lt;32&gt; = 1'0;
    const a1: logic&lt;32&gt; = 2'1;
    const a2: logic&lt;32&gt; = 3'x;
    const a3: logic&lt;32&gt; = 4'z;
}
</code></pre>
<h2 id="浮動小数点数"><a class="header" href="#浮動小数点数">浮動小数点数</a></h2>
<pre><code class="language-veryl">// 浮動小数点数
0123456789.0123456789
01_23_45_67_89.01_23_45_67_89

// 指数表記
0123456789.0123456789e+0123456789
01_23_45_67_89.01_23_45_67_89E-01_23_45_67_89
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="配列リテラル"><a class="header" href="#配列リテラル">配列リテラル</a></h1>
<p><code>'{}</code> は配列リテラルを表します。リテラル内には式、<code>repeat</code> キーワード、<code>default</code> キーワードを配置することができます。</p>
<pre><code class="language-veryl playground">module ModuleA {
    let _a: logic [3] = '{1, 2, 3};
    let _b: logic [3] = '{1 repeat 3}; // '{1, 1, 1}
    let _c: logic [3] = '{default: 3}; // '{3, 3, 3}
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="データ型"><a class="header" href="#データ型">データ型</a></h1>
<p>この章ではデータ型について説明します。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="組み込み型"><a class="header" href="#組み込み型">組み込み型</a></h1>
<h2 id="幅指定可能な4値データ型"><a class="header" href="#幅指定可能な4値データ型">幅指定可能な4値データ型</a></h2>
<p><code>logic</code> は4値（<code>0</code>、<code>1</code>、<code>x</code>、<code>z</code>）のデータ型です。幅は <code>logic</code> のあとの <code>&lt;&gt;</code> で指定できます。<code>&lt;X, Y, Z,,,&gt;</code> のように多次元指定も可能です。</p>
<pre><code class="language-veryl playground">module ModuleA {
    let _a: logic         = 1;
    let _b: logic&lt;10&gt;     = 1;
    let _c: logic&lt;10, 10&gt; = 1;
}
</code></pre>
<h2 id="幅指定可能な2値データ型"><a class="header" href="#幅指定可能な2値データ型">幅指定可能な2値データ型</a></h2>
<p><code>bit</code> は2値（<code>0</code>、<code>1</code>）のデータ型です。幅は <code>logic</code> のあとの <code>&lt;&gt;</code> で指定できます。<code>&lt;X, Y, Z,,,&gt;</code> のように多次元指定も可能です。</p>
<pre><code class="language-veryl playground">module ModuleA {
    let _a: bit         = 1;
    let _b: bit&lt;10&gt;     = 1;
    let _c: bit&lt;10, 10&gt; = 1;
}
</code></pre>
<h2 id="型修飾子"><a class="header" href="#型修飾子">型修飾子</a></h2>
<p><code>logic</code> と <code>bit</code> 型には以下の型修飾子を付けることができます。</p>
<ul>
<li><code>signed</code>: MSBは符号ビットとして扱われる</li>
<li><code>tri</code>: トライステート型</li>
</ul>
<pre><code class="language-veryl playground">module ModuleA {
    let _a: signed logic&lt;10&gt; = 1;
    let _b: tri logic   &lt;10&gt; = 1;
    let _c: signed bit  &lt;10&gt; = 1;
    let _d: tri bit     &lt;10&gt; = 1;
}
</code></pre>
<h2 id="整数型"><a class="header" href="#整数型">整数型</a></h2>
<p>整数型にはいくつかの種類があります。</p>
<ul>
<li><code>u8</code>：8ビットの符号なし整数</li>
<li><code>u16</code>：16ビットの符号なし整数</li>
<li><code>u32</code>：32ビットの符号なし整数</li>
<li><code>u64</code>：64ビットの符号なし整数</li>
<li><code>i8</code>：8ビットの符号付き整数</li>
<li><code>i16</code>：16ビットの符号付き整数</li>
<li><code>i32</code>：32ビットの符号付き整数</li>
<li><code>i64</code>：64ビットの符号付き整数</li>
</ul>
<pre><code class="language-veryl playground">module ModuleA {
    let _a: u8  = 1;
    let _b: u16 = 1;
    let _c: u32 = 1;
    let _d: u64 = 1;
    let _e: i8  = 1;
    let _f: i16 = 1;
    let _g: i32 = 1;
    let _h: i64 = 1;
}
</code></pre>
<h2 id="浮動小数点数型"><a class="header" href="#浮動小数点数型">浮動小数点数型</a></h2>
<p>浮動小数点数型にもいくつかの種類があります。</p>
<ul>
<li><code>f32</code>：32ビット浮動小数点数</li>
<li><code>f64</code>：64ビット浮動小数点数</li>
</ul>
<p>いずれも IEEE Std 754 準拠の表現です。</p>
<pre><code class="language-veryl playground">module ModuleA {
    let _a: f32 = 1.0;
    let _b: f64 = 1.0;
}
</code></pre>
<h2 id="文字列型"><a class="header" href="#文字列型">文字列型</a></h2>
<p><code>string</code> は文字列を表す型です。</p>
<pre><code class="language-veryl playground">module ModuleA {
    let _a: string = "";
}
</code></pre>
<h2 id="type型"><a class="header" href="#type型">Type型</a></h2>
<p><code>type</code> は型の種類を表す型です。<code>type</code> 型の変数は <code>param</code> か <code>const</code> としてのみ定義可能です。</p>
<pre><code class="language-veryl playground">module ModuleA {
    const a: type = logic;
    const b: type = logic&lt;10&gt;;
    const c: type = u32;
}
</code></pre>
<h2 id="ブーリアン型"><a class="header" href="#ブーリアン型">ブーリアン型</a></h2>
<p><code>bbool</code> と <code>lbool</code> は ブーリアンを表す <code>bit&lt;1&gt;</code> と <code>logic&lt;1&gt;</code> の型エイリアスです。<code>1'b1</code> と <code>1'b0</code> を表す <code>true</code> と <code>false</code> も使用できます。</p>
<pre><code class="language-veryl playground">module ModuleA {
    const A: bbool = true;
    const B: bbool = false;
    const C: lbool = true;
    const D: lbool = false;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ユーザ定義型"><a class="header" href="#ユーザ定義型">ユーザ定義型</a></h1>
<h2 id="構造体"><a class="header" href="#構造体">構造体</a></h2>
<p><code>struct</code> は複合データ型です。いくつかのフィールドを持つことができ、<code>.</code> 演算子を通してアクセスできます。</p>
<pre><code class="language-veryl playground">module ModuleA {
    struct StructA {
        member_a: logic    ,
        member_b: logic&lt;10&gt;,
        member_c: u32      ,
    }

    var a: StructA;

    assign a.member_a = 0;
    assign a.member_b = 1;
    assign a.member_c = 2;
}
</code></pre>
<div class="warning">
You can define `struct` data types within module and package declarations but not interface declaration.
</div>
<h2 id="列挙型"><a class="header" href="#列挙型">列挙型</a></h2>
<p><code>enum</code> は列挙型です。名前の付いたバリアントを複数持ち、<code>enum</code> 型の変数にはそのバリアントのうち1つだけをセットできます。バリアント名は <code>[enum name]::[variant name]</code> の形式で指定可能です。それぞれのバリアントは対応する整数値を持ち、<code>=</code> で指定することができます。指定されなかった場合は自動的に割り当てられます。</p>
<pre><code class="language-veryl playground">module A {
    enum EnumA: logic&lt;2&gt; {
        member_a,
        member_b,
        member_c = 3,
    }

    var a: EnumA;

    assign a = EnumA::member_a;
}
</code></pre>
<p><code>enum</code> の型が省略されている場合、適切なサイズの型がバリアントから自動的に推定されます。</p>
<pre><code class="language-veryl playground">module A {
    enum EnumA {
        member_a,
        member_b,
        member_c = 3,
    }
}
</code></pre>
<div class="warning">
You can define `enum` data types within module and package declarations but not interface declarations.
</div>
<h3 id="列挙型エンコーディング"><a class="header" href="#列挙型エンコーディング">列挙型エンコーディング</a></h3>
<p>デフォルトでは各バリアントの値が省略されたときは0から順に割り当てられます。この割り当てのエンコードを指定したい場合は、<code>#[enum_encoding]</code> アトリビュートを指定できます。使用できるエンコードは以下の通りです。</p>
<ul>
<li><code>sequential</code></li>
<li><code>onehot</code></li>
<li><code>gray</code></li>
</ul>
<pre><code class="language-veryl playground">module A {
    #[enum_encoding(sequential)]
    enum EnumA {
        member_a,
    }

    #[enum_encoding(onehot)]
    enum EnumB {
        member_a,
    }

    #[enum_encoding(gray)]
    enum EnumC {
        member_a,
    }
}
</code></pre>
<h2 id="ユニオン"><a class="header" href="#ユニオン">ユニオン</a></h2>
<p><code>union</code> はパックされたタグなしの直和型で、SystemVerilog では <code>packed union</code> にトランスパイルされます。ユニオンのそれぞれのバリアントの幅は同じでなければなりません。</p>
<pre><code class="language-veryl playground">module A {
    union UnionA {
        variant_a: logic&lt;8&gt;      ,
        variant_b: logic&lt;2, 4&gt;   ,
        variant_c: logic&lt;4, 2&gt;   ,
        variant_d: logic&lt;2, 2, 2&gt;,
    }
    var a          : UnionA;
    assign a.variant_a = 8'haa;
}
</code></pre>
<div class="warning">
You can define `union` data types within module and package declarations but not interface declarations.
</div>
<h2 id="型定義"><a class="header" href="#型定義">型定義</a></h2>
<p><code>type</code> キーワードを使って、スカラー型や配列型への型エイリアスを定義することができます。</p>
<pre><code class="language-veryl playground">module A {
    type word_t    = logic &lt;16&gt;     ;
    type regfile_t = word_t     [16];
    type octbyte   = bit   &lt;8&gt;  [8] ;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="配列"><a class="header" href="#配列">配列</a></h1>
<p>任意のデータ型に対して <code>[]</code> と付与することで配列を定義することができます。配列の長さは <code>[]</code> 内の値で指定します。</p>
<pre><code class="language-veryl playground">module ModuleA {
    struct StructA {
        A: logic,
    }
    enum EnumA: logic {
        A,
    }

    var a: logic       [20];
    var b: logic  &lt;10&gt; [20];
    var c: u32         [20];
    var d: StructA     [20];
    var e: EnumA       [20];

    assign a[0] = 0;
    assign b[0] = 0;
    assign c[0] = 0;
    assign d[0] = 0;
    assign e[0] = 0;
}
</code></pre>
<p><code>[X, Y, Z,,,]</code> のように多次元配列も定義できます。</p>
<pre><code class="language-veryl playground">module ModuleA {
    struct StructA {
        A: logic,
    }
    enum EnumA: logic {
        A,
    }

    var a: logic       [10, 20, 30];
    var b: logic  &lt;10&gt; [10, 20, 30];
    var c: u32         [10, 20, 30];
    var d: StructA     [10, 20, 30];
    var e: EnumA       [10, 20, 30];

    assign a[0][0][0] = 0;
    assign b[0][0][0] = 0;
    assign c[0][0][0] = 0;
    assign d[0][0][0] = 0;
    assign e[0][0][0] = 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="クロックとリセット"><a class="header" href="#クロックとリセット">クロックとリセット</a></h1>
<p><code>clock</code> はクロック配線を表す特別な型です。クロックの極性を指定するため以下の3種類があります。</p>
<ul>
<li><code>clock</code>: ビルド時の設定で指定される極性を持つクロック型</li>
<li><code>clock_posedge</code>: 正極性のクロック型</li>
<li><code>clock_negedge</code>: 負極性のクロック型</li>
</ul>
<p><code>reset</code> はリセット配線を表す特別な型です。リセットの極性と同期・非同期を指定するため以下の5種類があります。</p>
<ul>
<li><code>reset</code>: ビルド時の設定で指定される極性と同期性を持つリセット型</li>
<li><code>reset_async_high</code>: 正極性の非同期リセット型</li>
<li><code>reset_async_low</code>: 負極性の非同期リセット型</li>
<li><code>reset_sync_high</code>: 正極性の同期リセット型</li>
<li><code>reset_sync_low</code>: 負極性の同期リセット型</li>
</ul>
<p>特別な要件がなければ、コードの再利用を高めるため <code>clock</code> と <code>reset</code> の使用を推奨します。</p>
<pre><code class="language-veryl playground">module ModuleA (
    i_clk    : input '_ clock           ,
    i_clk_p  : input '_ clock_posedge   ,
    i_clk_n  : input '_ clock_negedge   ,
    i_rst    : input '_ reset           ,
    i_rst_a  : input '_ reset_async_high,
    i_rst_a_n: input '_ reset_async_low ,
    i_rst_s  : input '_ reset_sync_high ,
    i_rst_s_n: input '_ reset_sync_low  ,
) {
    var a: logic;
    var b: logic;
    var c: logic;

    always_ff (i_clk, i_rst) {
        if_reset {
            a = 0;
        } else {
            a = 1;
        }
    }

    always_ff (i_clk_p, i_rst_a) {
        if_reset {
            b = 0;
        } else {
            b = 1;
        }
    }

    always_ff (i_clk_n, i_rst_s_n) {
        if_reset {
            c = 0;
        } else {
            c = 1;
        }
    }
}
</code></pre>
<h2 id="デフォルトクロックとリセット"><a class="header" href="#デフォルトクロックとリセット">デフォルトクロックとリセット</a></h2>
<p>クロックが複数あるものの、 <code>always_ff</code> では単一のクロックしか使われない場合があります。このような場合に <code>default</code> 型修飾子を使ってデフォルトのクロックとリセットを明示することができます。</p>
<pre><code class="language-veryl playground">module ModuleA (
    i_clk   : input clock,
    i_clk_en: input logic,
) {
    let clk: '_ default clock = i_clk &amp; i_clk_en;

    var a: logic;

    always_ff {
        a = 0;
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="式"><a class="header" href="#式">式</a></h1>
<p>この章では式について説明します。式は変数や演算子、関数呼び出しなどを組み合わせたもので、評価して値を得ることができます。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="演算子の優先順位"><a class="header" href="#演算子の優先順位">演算子の優先順位</a></h1>
<p>式内での演算子の優先順位は SystemVerilog とほとんど同じです。</p>
<div class="table-wrapper"><table><thead><tr><th>演算子</th><th>結合性</th><th>優先順位</th></tr></thead><tbody>
<tr><td><code>()</code> <code>[]</code> <code>::</code> <code>.</code></td><td>左</td><td>高い</td></tr>
<tr><td><code>+</code> <code>-</code> <code>!</code> <code>~</code> <code>&amp;</code> <code>~&amp;</code> <code>|</code> <code>~|</code> <code>^</code> <code>~^</code> (単項)</td><td>左</td><td></td></tr>
<tr><td><code>**</code></td><td>左</td><td></td></tr>
<tr><td><code>*</code> <code>/</code> <code>%</code></td><td>左</td><td></td></tr>
<tr><td><code>+</code> <code>-</code> (二項)</td><td>左</td><td></td></tr>
<tr><td><code>&lt;&lt;</code> <code>&gt;&gt;</code> <code>&lt;&lt;&lt;</code> <code>&gt;&gt;&gt;</code></td><td>左</td><td></td></tr>
<tr><td><code>&lt;:</code> <code>&lt;=</code> <code>&gt;:</code> <code>&gt;=</code></td><td>左</td><td></td></tr>
<tr><td><code>==</code> <code>!=</code> <code>==?</code> <code>!=?</code></td><td>左</td><td></td></tr>
<tr><td><code>&amp;</code> (二項)</td><td>左</td><td></td></tr>
<tr><td><code>^</code> <code>~^</code> (二項)</td><td>左</td><td></td></tr>
<tr><td><code>|</code> (二項)</td><td>左</td><td></td></tr>
<tr><td><code>&amp;&amp;</code></td><td>左</td><td></td></tr>
<tr><td><code>||</code></td><td>左</td><td></td></tr>
<tr><td><code>=</code> <code>+=</code> <code>-=</code> <code>*=</code> <code>/=</code> <code>%=</code> <code>&amp;=</code> <code>^=</code> <code>|=</code> <br> <code>&lt;&lt;=</code> <code>&gt;&gt;=</code> <code>&lt;&lt;&lt;=</code> <code>&gt;&gt;&gt;=</code></td><td>なし</td><td></td></tr>
<tr><td><code>{}</code> <code>inside</code> <code>outside</code> <code>if</code> <code>case</code> <code>switch</code></td><td>なし</td><td>低い</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="関数呼び出し"><a class="header" href="#関数呼び出し">関数呼び出し</a></h1>
<p>関数は <code>function_name(argument)</code> の形式で呼び出すことができます。<code>$clog2</code> のような SystemVerilog のシステム関数も使えます。</p>
<pre><code class="language-veryl playground">package PackageA {
    function FunctionA (
        a: input logic,
        b: input logic,
    ) {}
}

module ModuleA {
    let _a: logic = PackageA::FunctionA(1, 1);
    let _b: logic = $clog2(1);
}
</code></pre>
<h2 id="名前付き引数"><a class="header" href="#名前付き引数">名前付き引数</a></h2>
<p>多くの引数を持つ関数では、名前付き引数による関数呼び出しが便利です。名前付き引数と位置引数を混在させることはできません。</p>
<pre><code class="language-veryl playground">module ModuleA {
    function FunctionA (
        a: input logic,
        b: input logic,
        c: input logic,
        d: input logic,
    ) {}

    let _a: logic = FunctionA(
        a: 1,
        b: 1,
        c: 1,
        d: 1,
    );

    // 位置引数と名前付き引数の混在はエラー
    //let _a: logic = FunctionA(
    //    1,
    //    2,
    //    a: 1,
    //    b: 1,
    //);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="連結"><a class="header" href="#連結">連結</a></h1>
<p><code>{}</code> はビット連結を表します。<code>{}</code> の中では <code>repeat</code> キーワードを使うことで指定されたオペランドを繰り返すこともできます。</p>
<pre><code class="language-veryl playground">module ModuleA {
    let a : logic&lt;10&gt; = 1;
    let b : logic&lt;10&gt; = 1;
    let _c: logic     = {a[9:0], b[4:3]};
    let _d: logic     = {a[9:0] repeat 10, b repeat 4};
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="if"><a class="header" href="#if">if</a></h1>
<p><code>if</code> を用いた条件式を使えます。<code>if</code> キーワードの後に条件を示す節を置きますが、<code>()</code> で囲む必要はありません。<code>?</code> のあとに条件が真である場合の式を、<code>:</code> のあとに条件が偽である場合の式を書きます。</p>
<pre><code class="language-veryl playground">module ModuleA {
    let a: logic&lt;10&gt; = 1;
    var b: logic&lt;10&gt;;

    assign b = if a == 0 ? 1 : if a &gt;: 1 ? 2 : 3;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="case--switch"><a class="header" href="#case--switch">Case / Switch</a></h1>
<p>もう一つの条件式が <code>case</code> です。<code>case</code> は <code>値: 式</code> という形式の条件を複数持ちます。もし <code>case</code> キーワードの後の式と条件の左側の値が一致すれば、その条件の右側の式が返されます。値としては <code>..=</code> のような範囲も指定できます。さらに x と z はワイルドカードとして扱われ、任意のビットにマッチします。<code>default</code> はそれ以外の条件が全て失敗したときに返される特別な条件です。case 式は常になんらかの値に評価される必要があるため <code>default</code> は必須です。</p>
<pre><code class="language-veryl playground">module ModuleA {
    let a: logic&lt;10&gt; = 1;
    var b: logic&lt;10&gt;;

    assign b = case a {
        0               : 1,
        1               : 2,
        3..=5           : 4,
        10'b00_0000_011x: 5, // 6 か 7 にマッチ
        default         : 6,
    };
}
</code></pre>
<p><code>switch</code> は <code>case</code> のもう一つの形式です。<code>switch</code> は <code>式: 式</code> という形式を持ち、左側の式の評価結果が1の場合に、右側の式が返されます。</p>
<pre><code class="language-veryl playground">module ModuleA {
    let a: logic&lt;10&gt; = 1;
    var b: logic&lt;10&gt;;

    assign b = switch {
        a == 0 : 1,
        a == 1 : 2,
        a == 2 : 4,
        default: 5,
    };
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ビット選択"><a class="header" href="#ビット選択">ビット選択</a></h1>
<p><code>[]</code> はビット選択演算子です。<code>[]</code> に式を指定すれば1ビットを選択できます。範囲選択する場合は <code>[式:式]</code> とします。</p>
<pre><code class="language-veryl playground">module ModuleA {
    let a: logic&lt;10&gt; = 1;
    var b: logic&lt;10&gt;;
    var c: logic&lt;10&gt;;

    assign b = a[3];
    assign c = a[4:0];
}
</code></pre>
<h2 id="位置と幅による選択"><a class="header" href="#位置と幅による選択">位置と幅による選択</a></h2>
<p><code>+:</code> と <code>-:</code> 記法は開始位置と幅により選択することができます。<code>[A+:B]</code> は <code>[(A+B-1):A]</code> を、 <code>[A-:B]</code> は <code>[A:(A-B+1)]</code> を意味します。</p>
<pre><code class="language-veryl playground">module ModuleA {
    let a: logic&lt;10&gt; = 1;
    var b: logic&lt;10&gt;;
    var c: logic&lt;10&gt;;

    assign b = a[3+:1];
    assign c = a[4-:2];
}
</code></pre>
<h2 id="ステップ付きインデックスによる選択"><a class="header" href="#ステップ付きインデックスによる選択">ステップ付きインデックスによる選択</a></h2>
<p><code>step</code> 記法はステップ付きのインデックスにより選択することができます。<code>[A step B]</code> は “ステップ <code>B</code> で分割したときのインデックス <code>A</code> を選択する” を意味し、<code>[(B*A)+:B]</code> と等しくなります。</p>
<pre><code class="language-veryl playground">module ModuleA {
    let a: logic&lt;10&gt; = 1;
    var b: logic&lt;10&gt;;

    assign b = a[2 step 3];
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="範囲"><a class="header" href="#範囲">範囲</a></h1>
<p>範囲は範囲演算子で指定できます。範囲演算子には以下の2種類があります。</p>
<ul>
<li><code>..</code>：半開区間</li>
<li><code>..=</code>：閉区間</li>
</ul>
<p>範囲は <code>for</code> 文などの場所で使うことができます。</p>
<pre><code class="language-veryl playground">module ModuleA {
    initial {
        for _i: u32 in 0..10 {}

        for _j: u32 in 0..=10 {}
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="msb--lsb"><a class="header" href="#msb--lsb">msb / lsb</a></h1>
<p><code>msb</code> と <code>lsb</code> は <code>[]</code> によるビット選択で使用できます。<code>msb</code> はオペランドの最上位ビットを意味します。<code>lsb</code> はオペランドの最下位ビットを意味し、0と同じです。</p>
<pre><code class="language-veryl playground">module ModuleA {
    let a : logic&lt;10&gt; = 1;
    let _b: logic&lt;10&gt; = a[msb - 3:lsb];
    let _c: logic&lt;10&gt; = a[msb - 1:lsb + 1];
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="inside--outside"><a class="header" href="#inside--outside">inside / outside</a></h1>
<p><code>inside</code> は 指定された式が <code>{}</code> で与えられた条件内にあるかどうかを調べます。条件は単一の式または<a href="05_language_reference/04_expression/./07_range.html">範囲</a>を指定できます。条件を満たすとき <code>inside</code> は <code>1</code> を、そうでなければ <code>0</code> を返します。<code>outside</code> はその逆です。</p>
<pre><code class="language-veryl playground">module ModuleA {
    var a: logic;
    var b: logic;

    assign a = inside 1 + 2 / 3 {0, 0..10, 1..=10};
    assign b = outside 1 * 2 - 1 {0, 0..10, 1..=10};
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="型キャスト"><a class="header" href="#型キャスト">型キャスト</a></h1>
<p><code>as</code> は型キャスト演算子です。基数付きあるいは基数なしの数値で指定するビット幅やユーザ定義型の型名をオペランドにとることができます。</p>
<pre><code class="language-veryl playground">module ModuleA {
    var a: EnumA   ;
    var b: logic&lt;2&gt;;
    let x: logic    = 0;

    enum EnumA: logic {
        A,
        B,
    }

    assign a = x as EnumA;
    assign b = x as 2;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="構造体コンストラクタ"><a class="header" href="#構造体コンストラクタ">構造体コンストラクタ</a></h1>
<p>構造体を初期化するために各メンバーにそれぞれ代入する代わりに構造体コンストラクタを使用することができます。特に <code>const</code> は各メンバーに代入することができないためコンストラクタによる初期化が必要です。</p>
<p><code>..default</code> 指定子は未指定のメンバーのためのデフォルト値を指定することができます。</p>
<pre><code class="language-veryl playground">module ModuleA {
    struct Param {
        a: bit&lt;10&gt;,
        b: bit&lt;10&gt;,
    }

    const p: Param = Param'{
        a: 10,
        b: 10,
    };

    const q: Param = Param'{
        a: 1,
        ..default(0) // すなわち `b: 0`
    };
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="文"><a class="header" href="#文">文</a></h1>
<p>この章では文について説明します。文は <code>always_ff</code> や <code>always_comb</code> などいくつかの宣言で使用することができます。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="代入"><a class="header" href="#代入">代入</a></h1>
<p>代入文は <code>変数 = 式;</code> の形式です。SystemVerilog と異なり、<code>always_comb</code> でも <code>always_ff</code> でも代入演算子は <code>=</code> です。以下のような代入演算子もあります。</p>
<ul>
<li><code>+=</code>：加算代入</li>
<li><code>-=</code>：減算代入</li>
<li><code>*=</code>：乗算代入</li>
<li><code>/=</code>：除算代入</li>
<li><code>%=</code>：剰余代入</li>
<li><code>&amp;=</code>：ビットAND代入</li>
<li><code>|=</code>：ビットOR代入</li>
<li><code>^=</code>：ビットXOR代入</li>
<li><code>&lt;&lt;=</code>：論理左シフト代入</li>
<li><code>&gt;&gt;=</code>：論理右シフト代入</li>
<li><code>&lt;&lt;&lt;=</code>：算術左シフト代入</li>
<li><code>&gt;&gt;&gt;=</code>：算術右シフト代入</li>
</ul>
<pre><code class="language-veryl playground">module ModuleA (
    i_clk: input clock,
) {
    let a: logic&lt;10&gt; = 1;
    var b: logic&lt;10&gt;;
    var c: logic&lt;10&gt;;
    var d: logic&lt;10&gt;;
    var e: logic&lt;10&gt;;

    always_comb {
        b =  a + 1;
        c += a + 1;
    }

    always_ff (i_clk) {
        d =  a + 1;
        e -= a + 1;
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="関数呼び出し-1"><a class="header" href="#関数呼び出し-1">関数呼び出し</a></h1>
<p>関数呼び出しは文として使うこともできます。この場合、関数の戻り値は無視されます。</p>
<pre><code class="language-veryl playground">module ModuleA {
    initial {
        $display("Hello, world!");
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="if-1"><a class="header" href="#if-1">if</a></h1>
<p><code>if</code> は文として使うこともできます。<code>if</code> 式との違いは <code>{}</code> 内に文を書くことです。</p>
<pre><code class="language-veryl playground">module ModuleA {
    let a: logic&lt;10&gt; = 1;
    var b: logic&lt;10&gt;;

    always_comb {
        if a == 0 {
            b = 1;
        } else if a &gt;: 1 {
            b = 2;
        } else {
            b = 3;
        }
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="case--switch-1"><a class="header" href="#case--switch-1">Case / Switch</a></h1>
<p><code>case</code> と <code>switch</code> は文として使うこともできます。各アームの右辺が文になる点を除けば <a href="05_language_reference/05_statement/../04_expression/05_case_switch.html">Case / Switch 式</a> と同じです。</p>
<pre><code class="language-veryl playground">module ModuleA {
    let a: logic&lt;10&gt; = 1;
    var b: logic&lt;10&gt;;
    var c: logic&lt;10&gt;;

    always_comb {
        case a {
            0: b = 1;
            1: b = 2;
            2: {
                b = 3;
                b = 3;
                b = 3;
            }
            default: b = 4;
        }
    }

    always_comb {
        switch {
            a == 0: c = 1;
            a == 1: c = 2;
            a == 2: {
                c = 3;
                c = 3;
                c = 3;
            }
            default: c = 4;
        }
    }
}
</code></pre>
<h2 id="cond_type-アトリビュート"><a class="header" href="#cond_type-アトリビュート"><code>cond_type</code> アトリビュート</a></h2>
<p>SystemVerilogにおける <code>unique</code> <code>unique0</code> <code>priority</code> を指定するために、<code>cond_type</code> アトリビュートを使うことができます。これらのアトリビュートは <code>case</code> あるいは <code>if</code> 文に付けることができます。</p>
<ul>
<li><code>unique</code>: アイテムは重複しない。マッチするアイテムがなければエラー。</li>
<li><code>unique0</code>: アイテムは重複しない。マッチするアイテムがなくてもエラーではない。</li>
<li><code>priority</code>: 最初にマッチしたアイテムが使われる。マッチするアイテムがなければエラー。</li>
</ul>
<pre><code class="language-veryl playground">module ModuleA {
    let a: logic&lt;10&gt; = 1;
    var b: logic&lt;10&gt;;

    always_comb {
        #[cond_type(unique)]
        case a {
            0: b = 1;
            1: b = 2;
        }
    }
}
</code></pre>
<p>これらのアトリビュートは合成時により積極的な最適化を可能にしますが、期待される条件を満たさない場合に合成結果が不正になる可能性があります。そのためデフォルトではアトリビュートは無視され、以下の設定がある場合のみ出力されます。</p>
<pre><code class="language-toml">[build]
emit_cond_type = true
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="for"><a class="header" href="#for">for</a></h1>
<p><code>for</code> 文は繰り返しを表します。<code>in</code> キーワードの前にループ変数を、後に<a href="05_language_reference/05_statement/../04_expression/07_range.html">範囲</a>を書きます。</p>
<p><code>break</code> を使ってループを中断することもできます。</p>
<pre><code class="language-veryl playground">module ModuleA {
    var a: logic&lt;10&gt;;

    always_comb {
        for i: u32 in 0..10 {
            a += i;

            if i == 5 {
                break;
            }
        }
    }
}
</code></pre>
<p><code>in</code> キーワードの後に <code>rev</code> キーワードを指定することで、ループを降順にすることができます。</p>
<pre><code class="language-veryl playground">module ModuleA {
    var a: logic&lt;10&gt;;

    always_comb {
        for i: i32 in rev 0..10 {
            a += i;

            if i == 5 {
                break;
            }
        }
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="return"><a class="header" href="#return">return</a></h1>
<p><code>return</code> 文は関数からの戻りを示します。<code>return</code> キーワードの後の式は関数の戻り値です。</p>
<pre><code class="language-veryl playground">module ModuleA {
    function FunctionA () -&gt; u32 {
        return 0;
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="let"><a class="header" href="#let">let</a></h1>
<p><code>let</code> 文はある名前に値を束縛します。これは <code>always_ff</code> 、 <code>always_comb</code> および関数宣言の中で使うことができます。</p>
<p><code>let</code> 文はブロック中のどこにでも置くことができます。</p>
<pre><code class="language-veryl playground">module ModuleA (
    i_clk: input clock,
) {
    var a: logic;
    var b: logic;
    var c: logic;

    always_ff (i_clk) {
        let x: logic = 1;
        a = x + 1;
    }

    always_comb {
        let y: logic = 1;
        b = y + 1;

        let z: logic = 1;
        c = z + 1;
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="宣言"><a class="header" href="#宣言">宣言</a></h1>
<p>この章では宣言について説明します。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="変数"><a class="header" href="#変数">変数</a></h1>
<p>変数宣言は <code>var</code> キーワードで始まり、変数名、<code>:</code>、変数の型と続きます。</p>
<p>未使用の変数は警告が発生します。<code>_</code> で始まる変数名は未使用変数を意味し、警告を抑制します。</p>
<p>宣言時に名前に値を束縛する場合は <code>var</code> の代わりに <code>let</code> を使います。</p>
<pre><code class="language-veryl playground">module ModuleA {
    var _a: logic        ;
    var _b: logic&lt;10&gt;    ;
    var _c: logic&lt;10, 10&gt;;
    var _d: u32          ;
    let _e: logic         = 1;

    assign _a = 1;
    assign _b = 1;
    assign _c = 1;
    assign _d = 1;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="パラメータ"><a class="header" href="#パラメータ">パラメータ</a></h1>
<p>パラメータは変数と同時に宣言できます。<code>param</code> キーワードはモジュールヘッダで使用することができ、インスタンス時に上書きできます。<code>const</code> キーワードはモジュール内で使用することができ、上書きできません。</p>
<pre><code class="language-veryl playground">module ModuleA #(
    param ParamA: u32 = 1,
) {
    const ParamB: u32 = 1;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="レジスタ"><a class="header" href="#レジスタ">レジスタ</a></h1>
<p>レジスタ変数とは <code>always_ff</code> で代入される変数です。合成フェーズでフリップフロップにマップされます。</p>
<p><code>always_ff</code> は必須のクロック変数、オプションのリセット変数、<code>{}</code> ブロックをとります。クロックとリセットは <code>()</code> に書きます。指定されたクロックとリセットは <code>clock</code> / <code>reset</code> 型を持ち、そのビット幅は1ビットでなければなりません。</p>
<p><code>if_reset</code> は <code>always_ff</code> に書ける特別なキーワードで、そのレジスタ変数のリセット条件を示します。<code>if_reset</code> を使う場合は <code>always_ff</code> のリセット変数は必須です。これを使うことで、リセットの極性と同期性を隠ぺいすることができます。実際の極性と同期性は <code>Veryl.toml</code> の <code>[build]</code> セクションで設定できます。</p>
<p>モジュール内にクロックとリセットが1つしかない場合、クロックとリセットの指定は省略できます。</p>
<pre><code class="language-veryl playground">module ModuleA (
    i_clk: input clock,
    i_rst: input reset,
) {
    var a: logic&lt;10&gt;;
    var b: logic&lt;10&gt;;
    var c: logic&lt;10&gt;;

    always_ff (i_clk) {
        a = 1;
    }

    always_ff (i_clk, i_rst) {
        if_reset {
            b = 0;
        } else {
            b = 1;
        }
    }

    always_ff {
        if_reset {
            c = 0;
        } else {
            c = 1;
        }
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="組み合わせ回路"><a class="header" href="#組み合わせ回路">組み合わせ回路</a></h1>
<p><code>always_comb</code> で代入される変数は組み合わせ回路を意味します。</p>
<pre><code class="language-veryl playground">module ModuleA {
    let a: logic&lt;10&gt; = 1;
    var b: logic&lt;10&gt;;

    always_comb {
        b = a + 1;
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="assign"><a class="header" href="#assign">assign</a></h1>
<p><code>assign</code> 宣言で変数に式を代入することができます。</p>
<pre><code class="language-veryl playground">module ModuleA {
    var a: logic&lt;10&gt;;

    assign a = 1;
}
</code></pre>
<p><code>assign</code> 宣言の左辺には連結も使用することができます。</p>
<pre><code class="language-veryl playground">module ModuleA {
    var a: logic&lt;10&gt;;
    var b: logic&lt;10&gt;;

    assign {a, b} = 1;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="関数"><a class="header" href="#関数">関数</a></h1>
<p>関数は <code>function</code> キーワードで宣言できます。引数は <code>()</code> 内に書き、戻り値の型を <code>-&gt;</code> の後に書きます。</p>
<p>関数が戻り値を持たない場合、<code>-&gt;</code> は省略できます。</p>
<pre><code class="language-veryl playground">module ModuleA {
    let a: logic&lt;10&gt; = 1;
    var b: logic&lt;10&gt;;

    function FunctionA (
        a: input logic&lt;10&gt;,
    ) -&gt; logic&lt;10&gt; {
        return a + 1;
    }

    function FunctionB (
        a: input logic&lt;10&gt;,
    ) {}

    assign b = FunctionA(a);

    initial {
        FunctionB(a);
    }
}
</code></pre>
<p>インターフェースのmodportは引数の型としても使用できます。与えられたmodportはSystemVerilog生成時にVerilogポートに展開されます。</p>
<pre><code class="language-veryl playground">interface InterfaceA::&lt;W: u32&gt; {
    var ready: logic   ;
    var valid: logic   ;
    var data : logic&lt;W&gt;;

    modport master {
        ready: input ,
        valid: output,
        data : output,
    }

    modport slave {
        ..converse(master)
    }
}

module ModuleA {
    inst a_if: InterfaceA::&lt;8&gt;;
    inst b_if: InterfaceA::&lt;8&gt;;

    function FunctionA (
        a_if: modport InterfaceA::&lt;8&gt;::slave ,
        b_if: modport InterfaceA::&lt;8&gt;::master,
    ) {
        a_if &lt;&gt; b_if;
    }

    always_comb {
        FunctionA(a_if, b_if);
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="initial--final"><a class="header" href="#initial--final">initial / final</a></h1>
<p><code>initial</code> ブロック内の文はシミュレーション開始時に実行され、<code>final</code> は終了時です。どちらも論理合成では無視され、デバッグやアサーションに使うことができます。</p>
<pre><code class="language-veryl playground">module ModuleA {
    initial {
        $display("initial");
    }

    final {
        $display("final");
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="アトリビュート"><a class="header" href="#アトリビュート">アトリビュート</a></h1>
<p>アトリビュートは変数宣言などいくつかの宣言に注釈を付けることができます。</p>
<h2 id="sv-アトリビュート"><a class="header" href="#sv-アトリビュート"><code>sv</code> アトリビュート</a></h2>
<p><code>sv</code> アトリビュートは SystemVerilog のアトリビュートを表し、<code>(*  *)</code> という形式の SystemVerilog アトリビュートに変換されます。</p>
<pre><code class="language-veryl playground">module ModuleA {
    #[sv("ram_style=\"block\"")]
    let _a: logic&lt;10&gt; = 1;
    #[sv("mark_debug=\"true\"")]
    let _b: logic&lt;10&gt; = 1;
}
</code></pre>
<h2 id="allow-アトリビュート"><a class="header" href="#allow-アトリビュート"><code>allow</code> アトリビュート</a></h2>
<p><code>allow</code> アトリビュートは指定されたリントチェックを無効化するために使用できます。</p>
<pre><code class="language-veryl playground">module ModuleA {
    #[allow(unused_variable)]
    let a: logic&lt;10&gt; = 1;
}
</code></pre>
<p>指定可能なリント名は以下の通りです。</p>
<ul>
<li>unused_variable</li>
<li>missing_reset_statement</li>
<li>missing_port</li>
</ul>
<h2 id="ifdefifndefelsifelse-アトリビュート"><a class="header" href="#ifdefifndefelsifelse-アトリビュート"><code>ifdef</code>/<code>ifndef</code>/<code>elsif</code>/<code>else</code> アトリビュート</a></h2>
<p><code>ifdef</code> と <code>ifndef</code> アトリビュートは定義された値によってコードブロックを有効にするかどうかを制御するために使用することができます。さらに、<code>ifdef</code> と <code>ifndef</code> のついたコードブロックに続けてオプションとして <code>elsif</code> と <code>else</code> アトリビュートの付いたブロックを書くこともできます。</p>
<p>以下の例はこれらのアトリビュートの使用方法と、各コードブロックが定義された値によって有効になる様子を示しています。</p>
<ul>
<li><code>ifdef</code>/<code>elsif</code>/<code>else</code> の順に宣言されたアトリビュート
<ul>
<li>もし <code>DEFINE_A</code> が定義されていれば、<code>#[ifdef(DEFINE_A)]</code> のついたコードブロック（コードブロックa）が有効になり、<code>#[ifndef(DEFINE_B)]</code> と <code>#[else]</code> のついたコードブロック（コードブロックbとc）は無効になります。</li>
<li><code>DEFINE_A</code> が定義されておらず、 <code>DEFINE_B</code> が定義されていれば、<code>#[elfif(DEFINE_B)]</code> のついたコードブロック（コードブロックb）が有効になり、<code>#[ifndef(DEFINE_A)]</code> と <code>#[else]</code> のついたコードブロック（コードブロックaとc）は無効になります。</li>
<li><code>DEFINE_A</code> と <code>DEFINE_B</code> が定義されていなければ、<code>#[else]</code> のついたコードブロックが有効になり、<code>#[ifndef(DEFINE_A)]</code> と <code>#[elsif(DEFINE_B)]</code> のついたコードブロック（コードブロックaとb）は無効になります。</li>
</ul>
</li>
<li><code>ifndef</code>/<code>else</code> の順に宣言されたアトリビュート
<ul>
<li>もし <code>DEFINE_D</code> が定義されていなければ、<code>#[ifndef(DEFINE_D)]</code> のついたコードブロック（コードブロックd）が有効になり、<code>#[else]</code> のついたコードブロック（コードブロックe）は無効になります。</li>
<li><code>DEFINE_D</code> が定義されていれば、<code>#[else]</code> のついたコードブロック（コードブロックe）が有効になり、<code>#[ifndef(DEFINE_D)]</code> のついたコードブロック（コードブロックd）は無効になります。</li>
</ul>
</li>
</ul>
<pre><code class="language-veryl playground">module ModuleA {
    #[ifdef(DEFINE_A)]
    {
        // コードブロック a
        let _a: logic&lt;10&gt; = 1;
    }
    #[elsif(DEFINE_B)]
    {
        // コードブロック b
        let _a: logic&lt;10&gt; = 2;
    }
    #[else]
    {
        // コードブロック c
        let _a: logic&lt;10&gt; = 3;
    }

    #[ifndef(DEFINE_D)]
    {
        // コードブロック d
        let _b: logic&lt;10&gt; = 4;
    }
    #[else]
    {
        // コードブロック e
        let _b: logic&lt;10&gt; = 5;
    }
}
</code></pre>
<p>生成されたコードにおける末尾カンマ周りの複雑な調整を回避するため、カンマ区切りリストの最後のアイテムに<code>ifdef</code>をつけることは禁止されています。</p>
<h2 id="expand-アトリビュート"><a class="header" href="#expand-アトリビュート"><code>expand</code> アトリビュート</a></h2>
<p><code>expand</code> アトリビュートが設定されているとき、<code>modport</code> のような構造化されたポートはVerilog のポートに展開されます。合成ツールによってはトップモジュールがそのようなポートを含んではならない場合があり、そのような場合にこのアトリビュートを使うことができます。使用可能な引数は以下の通りです。</p>
<ul>
<li><code>modport</code>: ポート方向が <code>modport</code> のポートを展開する</li>
</ul>
<pre><code class="language-veryl playground">interface InterfaceA::&lt;W: u32&gt; {
    var ready: logic   ;
    var valid: logic   ;
    var data : logic&lt;W&gt;;

    modport master {
        ready: input ,
        valid: output,
        data : output,
    }

    modport slave {
        ready: output,
        valid: input ,
        data : input ,
    }
}

#[expand(modport)]
module ModuleA (
    slave_if : modport InterfaceA::&lt;8&gt;::slave  [4],
    master_if: modport InterfaceA::&lt;8&gt;::master [4],
) {
    for i in 0..4 :g {
        connect slave_if[i] &lt;&gt; master_if[i];
    }
}

module ModuleB {
    inst a_if: InterfaceA::&lt;8&gt; [4];
    inst b_if: InterfaceA::&lt;8&gt; [4];

    inst u: ModuleA (
        slave_if : a_if,
        master_if: b_if,
    );
}
</code></pre>
<h2 id="align-アトリビュート"><a class="header" href="#align-アトリビュート"><code>align</code> アトリビュート</a></h2>
<p><code>align</code> アトリビュートはフォーマッタの垂直方向の整列を制御することができます。<code>number</code> が <code>align</code> の引数として指定されたとき、全ての数値は整列されます。<code>identifier</code> も使用可能です。</p>
<pre><code class="language-veryl playground">module ModuleA {
    let a  : logic&lt;32&gt; = 1;
    let aa : logic&lt;32&gt; = 1;
    let aaa: logic&lt;32&gt; = 1;

    let _b: logic = {
        a[0] repeat 1, a[0] repeat 1,
        aa[1] repeat 8, aa[1] repeat 8,
        aaa[2] repeat 16, aaa[2] repeat 16,
    };

    #[align(number, identifier)]
    let _c : logic = {
        a  [0 ] repeat 1 , a  [0 ] repeat 1 ,
        aa [1 ] repeat 8 , aa [1 ] repeat 8 ,
        aaa[2 ] repeat 16, aaa[2 ] repeat 16,
    };
}
</code></pre>
<h2 id="fmt-アトリビュート"><a class="header" href="#fmt-アトリビュート"><code>fmt</code> アトリビュート</a></h2>
<p><code>fmt</code> アトリビュートはフォーマットの方法を制御することができます。以下の引数がサポートされています。</p>
<ul>
<li><code>compact</code>: 改行なしのコンパクトなフォーマット</li>
</ul>
<pre><code class="language-veryl playground">module ModuleA {
    #[fmt(compact)]
    {
        inst u1: $sv::Module #( A: 1, B: 2 ) ( x: 1, y: _ );
        inst u2: $sv::Module #( A: 1, B: 2 ) ( x: 1, y: _ );
        inst u3: $sv::Module #( A: 1, B: 2 ) ( x: 1, y: _ );
        inst u4: $sv::Module #( A: 1, B: 2 ) ( x: 1, y: _ );
    }
}
</code></pre>
<ul>
<li><code>skip</code>: <code>veryl fmt</code> はモジュール、インターフェース、パッケージをフォーマットしない</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="生成"><a class="header" href="#生成">生成</a></h1>
<p>宣言や <code>for</code> や <code>if</code> を使って生成することができます。<code>:</code> で示すラベルは生成された複数の宣言を識別するのに必要です。</p>
<pre><code class="language-veryl playground">module ModuleA {
    var a: logic&lt;10&gt;;

    for i in 0..10 :label {
        if i &gt;: 5 :label {
            assign a[i] = i + 2;
        } else { // else 句のラベルは省略可能
            assign a[i] = i + 2;
        }
    }
}
</code></pre>
<p><code>in</code> キーワードの後に <code>rev</code> キーワードを付けることで、ループを降順にすることができます。</p>
<pre><code class="language-veryl playground">module ModuleA (
    i_a: input  logic,
    o_a: output logic,
    i_b: input  logic,
    o_b: output logic,
) {
    var a: logic&lt;4&gt;;
    var b: logic&lt;4&gt;;

    always_comb {
        a[lsb] = i_a;
        o_a    = a[msb];
    }

    for i in 0..4 :g_a {
        assign a[i + 1] = a[i];
    }

    always_comb {
        b[msb] = i_b;
        o_b    = b[lsb];
    }

    for i in rev 0..4 :g_b {
        if i != 0 :g {
            assign b[i - 1] = b[i];
        }
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="インスタンス-1"><a class="header" href="#インスタンス-1">インスタンス</a></h1>
<p><code>inst</code> キーワードはモジュールやインターフェースのインスタンス化を表します。インスタンスの名前は <code>inst</code> の後に、インスタンスの型は <code>:</code> の後に書きます。<code>#()</code> でパラメータオーバーライドを、<code>()</code> でポート接続を表します。</p>
<pre><code class="language-veryl playground">module ModuleA #(
    param paramA: u32 = 1,
) {
    let a: logic&lt;10&gt; = 1;
    let b: logic&lt;10&gt; = 1;

    inst instB: ModuleB #(
        paramA    , // 名前によるパラメータ代入
        paramB: 10,
    ) (
        a    , // 名前によるポート接続
        bb: b,
    );
}

module ModuleB #(
    param paramA: u32 = 1,
    param paramB: u32 = 1,
) (
    a : input logic&lt;10&gt;,
    bb: input logic&lt;10&gt;,
) {}
</code></pre>
<p><code>bind</code> 宣言もサポートされており、SystemVerilogのbind宣言に変換されます。SystemVerilogと異なり、ターゲットスコープとしてインスタンスを指定することはできず、モジュールかインターフェースのみ指定することができます。</p>
<pre><code class="language-veryl playground">interface InterfaceA {
    var a: logic;
    modport mp {
        a: input,
    }
}

module ModuleA (
    i_clk: input clock,
    i_rst: input reset,
) {
    inst a_if: InterfaceA;
}

module ModuleB (
    i_clk: input   clock         ,
    i_rst: input   reset         ,
    a_if : modport InterfaceA::mp,
) {}

module ModuleC {
    bind ModuleA &lt;- u0: ModuleB (
        i_clk  ,
        i_rst  ,
        a_if   ,
    );
}

bind ModuleA &lt;- u1: ModuleB (
    i_clk: i_clk,
    i_rst: i_rst,
    a_if : a_if ,
);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="名前付きブロック"><a class="header" href="#名前付きブロック">名前付きブロック</a></h1>
<p><code>{}</code> ブロックにラベルを付けることができます。そのような名前付きブロックは独立した名前空間を持ちます。</p>
<pre><code class="language-veryl playground">module ModuleA {
    :labelA {
        let _a: logic&lt;10&gt; = 1;
    }

    :labelB {
        let _a: logic&lt;10&gt; = 1;
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="インポート"><a class="header" href="#インポート">インポート</a></h1>
<p><code>import</code> 宣言は他のパッケージからシンボルをインポートします。モジュール、インターフェース、パッケージの要素としてだけでなくトップレベルにも配置することができます。<code>import</code> 宣言の引数には <code>package::*</code> のようなワイルドカードパターンを使用することができます。</p>
<pre><code class="language-veryl playground">// ファイルスコープインポート
import $sv::SvPackage::*;

package PackageA {
    const paramA: u32 = 1;
}

module ModuleA {
    import PackageA::*;
    import PackageA::paramA;
}
</code></pre>
<p>インポート宣言によるシンボルのインポートは、そのインポート宣言が置かれた名前空間内の任意の場所から参照できます。</p>
<pre><code class="language-veryl playground">package PackageA {
    const WIDTH: u32 = 8;
}

module ModuleA (
    i_d: input  logic&lt;WIDTH&gt;, // 有効な参照
    o_d: output logic&lt;WIDTH&gt;, // 有効な参照
) {
    import PackageA::WIDTH;

    let d  : logic&lt;WIDTH&gt; = i_d; // 有効な参照
    assign o_d = d;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="connect"><a class="header" href="#connect">Connect</a></h1>
<p>あるインターフェースをほかのインターフェースに接続するために各メンバーを代入する代わりに <code>connect</code> 宣言を使用することができます。<code>connect</code> 宣言はインターフェースの全てのメンバーを自動的に接続します。</p>
<p>代入の方向はmodportによって決まります。つまり <code>output</code> メンバーが <code>input</code> メンバーに代入されます。<code>connect</code> の引数がインターフェースインスタンスの場合、方向を決定するためにmodportの指定が必要です。</p>
<p>接続演算子 <code>&lt;&gt;</code> は <code>always_comb</code> 中でも使用することができます。</p>
<pre><code class="language-veryl playground">interface InterfaceA {
    var cmd  : logic;
    var ready: logic;

    modport master {
        cmd  : output,
        ready: input ,
    }

    modport slave {
        ..converse(master)
    }
}

module ModuleA (
    mst_if0: modport InterfaceA::master,
    slv_if0: modport InterfaceA::slave ,
    mst_if1: modport InterfaceA::master,
    slv_if1: modport InterfaceA::slave ,
) {
    inst bus_if0: InterfaceA;
    inst bus_if1: InterfaceA;

    connect mst_if0 &lt;&gt; bus_if0.slave;
    connect slv_if0 &lt;&gt; bus_if0.master;

    always_comb {
        mst_if1 &lt;&gt; bus_if1.slave;
    }
    always_comb {
        slv_if1 &lt;&gt; bus_if1.master;
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="モジュール-1"><a class="header" href="#モジュール-1">モジュール</a></h1>
<p>モジュールはソースコードの最上位コンポーネントの1つです。モジュールはオーバーライド可能なパラメータ、接続ポート、内部ロジックを持ちます。</p>
<p>オーバーライド可能なパラメータは <code>#()</code> 内で宣言できます。それぞれのパラメータ宣言は <code>param</code> キーワードで始まり、識別子、<code>:</code>、パラメータの型、デフォルト値で構成されます。</p>
<p>接続ポートは <code>()</code> 内で宣言できます。それぞれのポート宣言は識別子、<code>:</code>、ポートの方向、ポートの型で構成されます。利用可能なポート方向は以下の通りです。</p>
<ul>
<li><code>input</code>：入力ポート</li>
<li><code>output</code>：出力ポート</li>
<li><code>inout</code>：双方向ポート</li>
<li><code>modport</code>：インターフェースのmodport</li>
<li><code>interface</code>: ジェネリックインターフェース</li>
</ul>
<pre><code class="language-veryl playground">module ModuleA #(
    param ParamA: u32 = 0,
    param ParamB: u32 = 0,
) (
    a: input  logic,
    b: input  logic,
    c: input  logic,
    x: output logic,
) {
    always_comb {
        if c {
            x = a;
        } else {
            x = b;
        }
    }
}
</code></pre>
<h2 id="ポートのデフォルト値"><a class="header" href="#ポートのデフォルト値">ポートのデフォルト値</a></h2>
<p>モジュールのポートはデフォルトを持つことができます。デフォルト値を持つポートはインスタンス時に省略することができ、省略されたポートにはデフォルト値が割り当てられます。デフォルト値としては以下の値を取ることができます。</p>
<ul>
<li>入力ポート: リテラル、パッケージ内の <code>const</code></li>
<li>出力ポート: <code>_</code> (無名識別子)</li>
</ul>
<pre><code class="language-veryl playground">module ModuleA (
    a: input  logic    ,
    b: input  logic = 1,
    x: output logic    ,
    y: output logic = _,
) {
    assign x = a;
    assign y = b;
}

module ModubeB {
    inst instA: ModuleA (
        a: 1,
        // b は省略
        x: _,
        // y は省略
    );
}
</code></pre>
<h2 id="ジェネリックインターフェース"><a class="header" href="#ジェネリックインターフェース">ジェネリックインターフェース</a></h2>
<p>ジェネリックインターフェースは特別なポート方向指定です。<code>interface</code> が指定されたとき、そのポートには任意のインターフェースを接続可能です。<code>interface::ModPort</code> のように modport を付けることもできます。この場合、<code>ModPort</code> を持つインターフェースだけが接続できます。</p>
<pre><code class="language-veryl playground">module ModuleA (
    bus_if  : interface,
    slave_if: interface::slave,
) {}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="インターフェース-1"><a class="header" href="#インターフェース-1">インターフェース</a></h1>
<p>インターフェースはソースコードの最上位コンポーネントの1つです。インターフェースはオーバーライド可能なパラメータ、インターフェース定義を持ちます。</p>
<p>オーバーライド可能なパラメータについてはモジュールと同じです。</p>
<p>インターフェース定義では <code>modport</code> を宣言することができます。<code>modport</code> はモジュールのポート宣言で、ポートを束ねて接続するために使うことができます。</p>
<pre><code class="language-veryl playground">interface InterfaceA #(
    param ParamA: u32 = 0,
    param ParamB: u32 = 0,
) {
    var a: logic;
    var b: logic;

    modport master {
        a: output,
        b: input ,
    }

    modport slave {
        b: input ,
        a: output,
    }
}
</code></pre>
<p>さらに、<code>import</code> キーワードを付けて指定された関数は modport を通して呼び出すことができます。</p>
<pre><code class="language-veryl playground">interface InterfaceA {
    var a: logic;
    var b: logic;

    function a_and_b -&gt; logic&lt;2&gt; {
        return {a, b};
    }

    modport mp {
        a      : input ,
        b      : input ,
        a_and_b: import,
    }
}
module ModuleA (
    ab_if: modport InterfaceA::mp,
) {
    let _ab: logic&lt;2&gt; = ab_if.a_and_b();
}
</code></pre>
<h2 id="modportのデフォルトメンバー"><a class="header" href="#modportのデフォルトメンバー">modportのデフォルトメンバー</a></h2>
<p>modportの全てのメンバーを指定する代わりに、以下のようにデフォルトメンバーを指定することができます。</p>
<ul>
<li><code>..input</code>: インターフェース内の全ての変数を <code>input</code> として追加</li>
<li><code>..output</code>: インターフェース内の全ての変数を <code>output</code> として追加</li>
<li><code>..same(modport_name)</code>: <code>modport_name</code> と同じ変数を同じ方向で追加</li>
<li><code>..converse(modport_name)</code>: <code>modport_name</code> と同じ変数を、方向を逆にして追加</li>
</ul>
<p>デフォルトメンバーの指定は通常の明示的なメンバーと一緒に使うこともできます。</p>
<pre><code class="language-veryl playground">interface InterfaceA {
    var a: logic;
    var b: logic;
    var c: logic;

    modport master {
        a: output,
        b: input ,
        c: input ,
    }

    modport slave {
        ..converse(master)
    }

    modport monitor {
        ..input
    }

    modport driver {
        b: input,
        ..output
    }
}
</code></pre>
<h2 id="インターフェースインスタンスとmodportポートの接続"><a class="header" href="#インターフェースインスタンスとmodportポートの接続">インターフェースインスタンスとmodportポートの接続</a></h2>
<p>インターフェースインスタンスとmodportポートは、SystemVerilogと同様に、互換性のあるモジュールポートあるいは <code>generic</code> インターフェースに接続することができます。</p>
<pre><code class="language-veryl playground">interface InterfaceA {
    var a: logic;

    modport mp {
        a: output,
    }
}
module ModuleA (
    foo_if: modport InterfaceA::mp,
    bar_if: modport InterfaceA::mp,
) {
    always_comb {
        foo_if.a = '0;
        bar_if.a = '0;
    }
}
module ModuleB (
    foo_if: modport InterfaceA::mp,
) {
    inst bar_if: InterfaceA;
    inst u: ModuleA (
        foo_if: foo_if,
        bar_if: bar_if,
    );
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="パッケージ-1"><a class="header" href="#パッケージ-1">パッケージ</a></h1>
<p>パッケージはソースコードの最上位コンポーネントの1つです。パッケージはパラメータや関数などいくつかの宣言をまとめることができます。</p>
<p>パッケージ内の要素にアクセスするには、<code>::</code> 記号を使って <code>PackageA::ParamA</code> のようにします。</p>
<pre><code class="language-veryl playground">package PackageA {
    const ParamA: u32 = 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="systemverilogとの相互運用"><a class="header" href="#systemverilogとの相互運用">SystemVerilogとの相互運用</a></h1>
<p>SystemVerilogの要素にアクセスする場合は <code>$sv</code> 名前空間を使えます。例えば、SystemVerilogソースコードの “ModuleA” は <code>$sv::ModuleA</code> です。Veryl はこれらの要素が実際に存在するかどうかは確認しません。</p>
<p>Verylコンパイラは <code>$sv::</code> を除いたパス名をそのまま出力します。そのため Verilog や VHDL のような他のHDLのシンボルも参照できます。それぞれのシンボルが解決できるかどうかは実装（シミュレータや合成ツール）に依存します。</p>
<pre><code class="language-veryl playground">module ModuleA {
    let _a: logic = $sv::PackageA::ParamA;

    inst b: $sv::ModuleB;
    inst c: $sv::InterfaceC;
}
</code></pre>
<p>Veryl のキーワードとして使われている識別子にアクセスするには生識別子を使います。</p>
<pre><code class="language-veryl playground">module ModuleA (
    i_clk: input clock,
) {
    inst a: $sv::ModuleA (
        // clock: i_clk
        // ^ `clock` はキーワードなので構文エラー
        // 代わりに `r#clock` を使います
        r#clock: i_clk,
    );
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="可視性"><a class="header" href="#可視性">可視性</a></h1>
<p>デフォルトではプロジェクトのトップレベルアイテム（モジュール、インターフェース、パッケージ）はプライベートです。プライベートとは他のプロジェクトから参照できないことを意味します。</p>
<p><code>pub</code> キーワードによって他のプロジェクトから見えるように指定することができます。<code>veryl doc</code> コマンドはパブリックなアイテムの <a href="05_language_reference/../05_development_environment/09_documentation.html">ドキュメント</a> のみを生成します。</p>
<pre><code class="language-veryl playground">pub module ModuleA {}

pub interface InterfaceA {}

pub package PackageA {}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="他言語組み込み"><a class="header" href="#他言語組み込み">他言語組み込み</a></h1>
<h2 id="embed-宣言"><a class="header" href="#embed-宣言"><code>embed</code> 宣言</a></h2>
<p><code>embed</code> 宣言により他言語をコードに埋め込むことができます。<code>embed</code> 宣言の第一引数は埋め込み方法です。以下の方法がサポートされています。</p>
<ul>
<li><code>inline</code>: コードをそのまま展開する</li>
<li><code>cocotb</code>: cocotb テストとして扱う</li>
</ul>
<p>コードブロックは <code>lang{{{</code> で始まり、<code>}}}</code> で終わります。以下の <code>lang</code> 指示子がサポートされています。</p>
<ul>
<li><code>sv</code>: SystemVerilog</li>
<li><code>py</code>: Python</li>
</ul>
<pre><code class="language-veryl playground">embed (inline) sv{{{
    module ModuleSv;
    endmodule
}}}
</code></pre>
<p><code>inline</code> かつ <code>sv</code> 指定された <code>embed</code> 宣言はモジュール宣言、インターフェース宣言及びパッケージ宣言の中に配置することができます。これはSystemVerilogテストベンチとの統合に使用できます。</p>
<pre><code class="language-veryl playground">#[allow(unused_variable)]
interface bus_monitor_if {
    var clk    : clock   ;
    var ready  : logic   ;
    var valid  : logic   ;
    var payload: logic&lt;8&gt;;

    embed (inline) sv{{{
        clocking monitor_cb @(posedge clk);
            input ready;
            input valid;
            input payload;
        endclocking
    }}}

}
</code></pre>
<p>Verylコード内で定義された識別子は <code>embed</code> コードブロック内に <code>\{</code> と <code>\}</code> を用いて記述することができます。これらの識別子はコンパイル時に解決され、解決された名前がその場所に挿入されます。</p>
<pre><code class="language-veryl playground">module Module47A {}

module Module47B::&lt;V: u32&gt; {}

module Module47C {
    inst u_a: Module47A;

    embed (inline) sv{{{
        bind u_a \{ Module47B::&lt;32&gt; \} u_b32 ();
        bind u_a \{ Module47B::&lt;64&gt; \} u_b64 ();
    }}}

}
</code></pre>
<h2 id="include-宣言"><a class="header" href="#include-宣言"><code>include</code> 宣言</a></h2>
<p><code>include</code> 宣言により他言語のファイルを含めることができます。<code>include</code> 宣言の第一引数は <code>embed</code> 宣言と同じです。第二引数はソースコードからの相対ファイルパスです。</p>
<pre><code class="language-veryl">include(inline, "module.sv");
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="組み込みテスト"><a class="header" href="#組み込みテスト">組み込みテスト</a></h1>
<p>組み込みテストは <code>#[test(test_name)]</code> アトリビュートでマークすることができます。マークされたブロックはテストとして認識され、 <code>veryl test</code> コマンドによって実行されます。</p>
<p>組み込みテストにはいくつかの種類があります。</p>
<ul>
<li>SystemVerilogテスト</li>
<li><a href="https://www.cocotb.org">cocotb</a> テスト</li>
</ul>
<p><code>veryl test</code> で使用される RTLシミュレータについては <a href="05_language_reference/../06_development_environment/07_simulator.html">シミュレータ</a> を参照してください。<code>--wave</code> オプションで波形を生成することもできます。</p>
<h2 id="systemverilogテスト"><a class="header" href="#systemverilogテスト">SystemVerilogテスト</a></h2>
<p>SystemVerilog テストは <code>inline</code> 指定子で記述することができます。ブロックのトップレベルモジュールはテスト名と同じでなければなりません。</p>
<p><code>$info</code>、<code>$warning</code>、<code>$error</code>、<code>$fatal</code> システム関数によるメッセージは Veryl コンパイラにより実行ログとして表示されます。<code>$error</code> と <code>$fatal</code> の呼び出しはテストの失敗として扱われます。</p>
<p>以下の例では SystemVerilog のソースコードを <code>embed</code> 宣言で埋め込み、テストとしてマークしています。</p>
<pre><code class="language-veryl playground">#[test(test1)]
embed (inline) sv{{{
    module test1;
        initial begin
            assert (0) else $error("error");
        end
    endmodule
}}}
</code></pre>
<h2 id="cocotb-テスト"><a class="header" href="#cocotb-テスト">cocotb テスト</a></h2>
<p>cocotb テストは <code>cocotb</code> 指定子で記述することができます。テスト対象のモジュール名は <code>#[test]</code> アトリビュートの第二引数で指定します。</p>
<pre><code class="language-veryl playground">#[test(test1, ModuleA)]
embed (cocotb) py{{{
    # cocotb code
}}}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ジェネリクス"><a class="header" href="#ジェネリクス">ジェネリクス</a></h1>
<p>ジェネリクスはパラメータオーバーライドでは実現できないアイテムのパラメータ化を可能にします。以下のアイテムがジェネリクスをサポートしています。</p>
<ul>
<li>関数</li>
<li>モジュール</li>
<li>インターフェース</li>
<li>パッケージ</li>
<li>構造体</li>
<li>ユニオン</li>
</ul>
<p>それぞれのジェネリック定義はジェネリックパラメータ（<code>T</code> のような大文字1文字がよく使われます）を持ち、定義内で識別子や式として配置できます。ジェネリックパラメータはアイテムの識別子の後に <code>::&lt;&gt;</code> を用いて宣言します。</p>
<p>各ジェネリックパラメータにはコロンの後に <code>T: TypeName</code> のようなジェネリック境界が必要です。ジェネリック境界はどのような値をそのパラメータに渡すことができるかを示します。使用可能なジェネリック境界は以下の通りです。</p>
<ul>
<li><code>type</code>: 任意の型を渡すことができる</li>
<li><code>inst: X</code> : <code>X</code> のインスタンス</li>
<li>名前付きプロトタイプ、ユーザ定義型、組み込みのデータ型</li>
</ul>
<p>名前付きプロトタイプは特別なジェネリック境界です。詳細は <a href="05_language_reference/14_generics/02_prototype.html">プロトタイプ</a> を参照してください。</p>
<p>ジェネリクスを使用するためには <code>::&lt;&gt;</code> を用いて実パラメータを与えます。実パラメータとしては数値リテラルと <code>::</code> で連結された識別子を使用することができます。</p>
<p>さらに、実パラメータはジェネリクス定義位置から参照できなければなりません。例えば、モジュール名はプロジェクト全体から参照できるので、実パラメータとして使用できます。一方、ローカルパラメータは多くの場合、実パラメータとして使用できません。これはローカルパラメータがジェネリクス定義位置からは参照できない場合に発生します。</p>
<h2 id="ジェネリック関数"><a class="header" href="#ジェネリック関数">ジェネリック関数</a></h2>
<pre><code class="language-veryl playground">module ModuleA {
    function FuncA::&lt;T: u32&gt; (
        a: input logic&lt;T&gt;,
    ) -&gt; logic&lt;T&gt; {
        return a + 1;
    }

    let _a: logic&lt;10&gt; = FuncA::&lt;10&gt;(1);
    let _b: logic&lt;20&gt; = FuncA::&lt;20&gt;(1);
}
</code></pre>
<h2 id="ジェネリックモジュールインターフェース"><a class="header" href="#ジェネリックモジュールインターフェース">ジェネリックモジュール/インターフェース</a></h2>
<pre><code class="language-veryl playground">module ModuleA {
    inst u0: ModuleB::&lt;ModuleC&gt;;
    inst u1: ModuleB::&lt;ModuleD&gt;;
}

proto module ProtoA;

module ModuleB::&lt;T: ProtoA&gt; {
    inst u: T;
}

module ModuleC for ProtoA {}
module ModuleD for ProtoA {}
</code></pre>
<h2 id="ジェネリックパッケージ"><a class="header" href="#ジェネリックパッケージ">ジェネリックパッケージ</a></h2>
<pre><code class="language-veryl playground">package PackageA::&lt;T: u32&gt; {
    const X: u32 = T;
}

module ModuleA {
    const A: u32 = PackageA::&lt;1&gt;::X;
    const B: u32 = PackageA::&lt;2&gt;::X;
}
</code></pre>
<h2 id="ジェネリック構造体"><a class="header" href="#ジェネリック構造体">ジェネリック構造体</a></h2>
<pre><code class="language-veryl playground">package PackageA {
    type TypeB = u32;
    type TypeC = u64;
}

module ModuleA {
    type TypeA = i32;

    struct StructA::&lt;T: type&gt; {
        A: T,
    }

    // ローカルに定位された型が使用できています
    // これは `TypeA` が `StructA` の定義位置から参照できるためです
    var _a: StructA::&lt;TypeA&gt;          ;
    var _b: StructA::&lt;PackageA::TypeB&gt;;
    var _c: StructA::&lt;PackageA::TypeC&gt;;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="デフォルトパラメータ"><a class="header" href="#デフォルトパラメータ">デフォルトパラメータ</a></h1>
<p>ジェネリックパラメータはその後に <code>=</code> を加えることでデフォルト値を指定することができます。呼び出し側でパラメータ指定が省略された場合にデフォルト値が使われます。</p>
<pre><code class="language-veryl playground">module ModuleA {
    function FuncA::&lt;T: u32 = 10&gt; (
        a: input logic&lt;T&gt;,
    ) -&gt; logic&lt;T&gt; {
        return a + 1;
    }

    let _a: logic&lt;10&gt; = FuncA::&lt;&gt;(1);
    let _b: logic&lt;20&gt; = FuncA::&lt;20&gt;(1);
}
</code></pre>
<p>デフォルトパラメータはジェネリックパラメータリストの最後に置く必要があります。そうでなければ、どのパラメータが省略されたかが曖昧になるためです。</p>
<pre><code class="language-veryl playground">module ModuleA {
    function FuncA::&lt;T: u32, U: u32 = 1&gt; (
        a: input logic&lt;T&gt;,
    ) -&gt; logic&lt;T&gt; {
        return a + U;
    }

    // エラー
    //function FuncA::&lt;T: u32 = 1, U: u32&gt; (
    //    a: input logic&lt;T&gt;,
    //) -&gt; logic&lt;T&gt; {
    //    return a + U;
    //}

    let _a: logic&lt;10&gt; = FuncA::&lt;10&gt;(1);
    let _b: logic&lt;20&gt; = FuncA::&lt;20, 2&gt;(1);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="プロトタイプ"><a class="header" href="#プロトタイプ">プロトタイプ</a></h1>
<p>プロトタイプは特別なジェネリック境界で、ジェネリックパラメータに渡せるプロトタイプを示します。現在はモジュールプロトタイプ、インターフェースプロトタイプ、パッケージプロトタイプがサポートされています。</p>
<h2 id="モジュールプロトタイプ"><a class="header" href="#モジュールプロトタイプ">モジュールプロトタイプ</a></h2>
<p>以下の例では、<code>ProtoA</code> がパラメータ <code>A</code> とポート <code>i_dat</code> <code>o_dat</code> を持つモジュールプロトタイプです。<code>T: ProtoA</code> のように制約することで、ジェネリックパラメータ <code>T</code> がそれらのパラメータとポートを持つ必要があることが示されます。</p>
<p>プロトタイプを使うには <code>for</code> による実装が必要です。<code>ModuleC</code> と <code>ModuleD</code> は <code>for ProtoA</code> 指定により、 <code>ProtoA</code> の条件を満たすことが示されています。これにより、それらのモジュールは <code>ModuleB</code> の ジェネリックパラメータ <code>T</code> として使用できるようになります。</p>
<pre><code class="language-veryl playground">module ModuleA {
    inst u0: ModuleB::&lt;ModuleC&gt;;
    inst u1: ModuleB::&lt;ModuleD&gt;;
}

proto module ProtoA #(
    param A: u32 = 1,
) (
    i_dat: input  logic,
    o_dat: output logic,
);

module ModuleB::&lt;T: ProtoA&gt; {
    inst u: T (
        i_dat: 0,
        o_dat: _,
    );
}

module ModuleC for ProtoA #(
    param A: u32 = 1,
) (
    i_dat: input  logic,
    o_dat: output logic,
) {
    assign o_dat = i_dat;
}

module ModuleD for ProtoA #(
    param A: u32 = 1,
) (
    i_dat: input  logic,
    o_dat: output logic,
) {
    assign o_dat = ~i_dat;
}
</code></pre>
<h2 id="インターフェースプロトタイプ"><a class="header" href="#インターフェースプロトタイプ">インターフェースプロトタイプ</a></h2>
<p>以下の例では、<code>ProtoA</code> が定数 <code>A</code> と変数 <code>raedy</code>/<code>valid</code>/<code>data</code>、関数 <code>ack</code>、modport <code>master</code>を持つインターフェースプロトタイプです。<code>BUS_IF</code> は <code>ProtoA</code> で制約されているので、それらのメンバーを持つことが保証されており、参照することができます。</p>
<pre><code class="language-veryl playground">proto interface ProtoA {
    const WIDTH: u32;

    var ready: logic       ;
    var valid: logic       ;
    var data : logic&lt;WIDTH&gt;;

    function ack() -&gt; logic ;

    modport master {
        ready: input ,
        valid: output,
        data : output,
        ack  : import,
    }
}

interface InterfaceA::&lt;W: u32&gt; for ProtoA {
    const WIDTH: u32 = W;

    var ready: logic       ;
    var valid: logic       ;
    var data : logic&lt;WIDTH&gt;;

    function ack () -&gt; logic {
        return ready &amp;&amp; valid;
    }

    modport master {
        ready: input ,
        valid: output,
        data : output,
        ack  : import,
    }
}

module ModuleA::&lt;BUS_IF: ProtoA&gt; (
    bus_if: modport BUS_IF::master,
) {
    connect bus_if &lt;&gt; 0;
}

module ModuleB {
    inst bus_if: InterfaceA::&lt;8&gt;;

    inst u: ModuleA::&lt;InterfaceA::&lt;8&gt;&gt; (
        bus_if: bus_if,
    );
}
</code></pre>
<h2 id="パッケージプロトタイプ"><a class="header" href="#パッケージプロトタイプ">パッケージプロトタイプ</a></h2>
<p>以下の例では、<code>ProtoA</code> が型 <code>data_a</code> と型 <code>data_b</code> を持つパッケージプロトタイプです。<code>PKG</code> は <code>ProtoA</code> で制約されているので、<code>data_a</code> と <code>data_b</code> を持つことが保証されており、それらを参照することができます。</p>
<pre><code class="language-veryl playground">proto package ProtoA {
    type data_a;
    type data_b;
}

package PackageA::&lt;A: u32, B: u32&gt; for ProtoA {
    type data_a = logic&lt;A&gt;;
    type data_b = logic&lt;B&gt;;
}

module ModuleA::&lt;PKG: ProtoA&gt; {
    let _a: PKG::data_a = 0;
}
</code></pre>
<h2 id="プロトタイプの要素"><a class="header" href="#プロトタイプの要素">プロトタイプの要素</a></h2>
<p>以下の要素はモジュール、インターフェース、パッケージのプロトタイプ内で宣言することができます。</p>
<p>テーブルにどのプロトタイプがどの要素を持てるかをまとめます。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">プロトタイプ</th><th style="text-align: left">パラメータ</th><th style="text-align: left">ポート</th><th style="text-align: left">定数</th><th style="text-align: left">変数</th><th style="text-align: left">型定義</th><th style="text-align: left">構造体/列挙型/ユニオン</th><th style="text-align: left">関数</th><th style="text-align: left">エイリアス</th><th style="text-align: left">modport</th></tr></thead><tbody>
<tr><td style="text-align: left">モジュール</td><td style="text-align: left">v</td><td style="text-align: left">v</td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">インターフェース</td><td style="text-align: left">v</td><td style="text-align: left"></td><td style="text-align: left">v</td><td style="text-align: left">v</td><td style="text-align: left">v</td><td style="text-align: left"></td><td style="text-align: left">v</td><td style="text-align: left"></td><td style="text-align: left">v</td></tr>
<tr><td style="text-align: left">パッケージ</td><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left">v</td><td style="text-align: left"></td><td style="text-align: left">v</td><td style="text-align: left">v</td><td style="text-align: left">v</td><td style="text-align: left">v</td><td style="text-align: left"></td></tr>
</tbody></table>
</div>
<h3 id="パラメータ-1"><a class="header" href="#パラメータ-1">パラメータ</a></h3>
<p>パラメータプロトタイプは識別子とデータ型を指定します。デフォルト値の指定は省略できます。</p>
<pre><code class="language-veryl">proto module ModuleA #(
    param A: u32 = 0,
    param B: u32,
);
</code></pre>
<h3 id="ポート"><a class="header" href="#ポート">ポート</a></h3>
<p>ポートプロトタイプは識別子と方向、データ型を指定します。</p>
<pre><code class="language-veryl">proto module ModuleA (
    i_d: input  logic,
    o_d: output logic,
);
</code></pre>
<h3 id="定数"><a class="header" href="#定数">定数</a></h3>
<p>定数プロトタイプは識別子とデータ型を指定します。ジェネリックなパラメータのプレースホルダとして使用できます。</p>
<pre><code class="language-veryl">proto package ProtoPkg {
    const WIDTH: u32;
}
package PkgA::&lt;W: u32&gt; for ProtoPkg {
    const WIDTH: u32 = W;
}
</code></pre>
<h3 id="変数-1"><a class="header" href="#変数-1">変数</a></h3>
<p>変数プロトタイプは識別子とデータ型を指定します。これらは <code>var</code> 及び <code>let</code> 宣言で使用することができます。</p>
<pre><code class="language-veryl">proto interface ProtoA {
    var a: logic;
    var b: logic;
}
interface InterfaceA for ProtoA {
    var a: logic;
    let b: lgoic = 0;
}
</code></pre>
<h3 id="型定義-1"><a class="header" href="#型定義-1">型定義</a></h3>
<p>Typedefプロトタイプは型エイリアスの識別子を指定します。ジェネリックなパラメータのプレースホルダとして使用できます。</p>
<pre><code class="language-veryl">proto package ProtoPkg {
    type data_t;
}
package PkgA::&lt;W: u32&gt; for ProtoPkg {
    type data_t = logic&lt;W&gt;;
}
</code></pre>
<p>さらに、typedefプロトタイプは右辺に実際の型を指定することができます。これにより他のパッケージで定義された型をそのプロトタイプパッケージに導入し、他のコンポーネントから参照することができます。</p>
<pre><code class="language-veryl playground">package FooPkg {
    struct Foo {
        foo: logic,
    }
}
proto package BarProtoPkg {
    type Foo = FooPkg::Foo;
}
package BarPkg for BarProtoPkg {
    type Foo = FooPkg::Foo;
}
module ModuleA::&lt;PKG: BarProtoPkg&gt; {
    var _foo    : PKG::Foo;
    assign _foo.foo = 0;
}
module ModuleB {
    inst u: ModuleA::&lt;BarPkg&gt;;
}
</code></pre>
<h3 id="構造体列挙型ユニオン"><a class="header" href="#構造体列挙型ユニオン">構造体/列挙型/ユニオン</a></h3>
<p>構造体、列挙型、ユニオンプロトタイプは型の識別子と各メンバーの識別子、データ型を指定します。</p>
<pre><code class="language-veryl">proto package ProtoPkg {
    struct Foo {
        a: logic,
        b: logic,
    }

    enum Bar {
        C,
        D,
    }

    union Baz {
        e: logic,
        f: logic,
    }
}
</code></pre>
<h3 id="関数-1"><a class="header" href="#関数-1">関数</a></h3>
<p>関数プロトタイプは識別子と戻り値のデータ型、引数の方向とデータ型を指定します。</p>
<pre><code class="language-veryl">proto package ProtoPkg {
    function foo (a: input logic, b: input logic) -&gt; logic;
}
</code></pre>
<h3 id="モジュールインターフェースパッケージ-エイリアス"><a class="header" href="#モジュールインターフェースパッケージ-エイリアス">モジュール/インターフェース/パッケージ エイリアス</a></h3>
<p>モジュール、インターフェース、パッケージのエイリアス プロトタイプは識別子とモジュール、インターフェース、パッケージのプロトタイプを指定します。そのエイリアスの実際の型は与えられたプロトタイプに制約されます。</p>
<pre><code class="language-veryl">proto module ProtoRamWrapper;

proto package ProtoPkg {
    alias module ram: ProtoRamWrapper;
}

package Pkg::&lt;RAM: ProtoRamWrapper&gt; for ProtoPkg {
    alias module ram = RAM;
}

module RamWrapper for ProtoRamWrapper {}

module top {
  inst u_ram: Pkg::&lt;RamWrapper&gt;::ram;
}
</code></pre>
<h3 id="modport"><a class="header" href="#modport">modport</a></h3>
<p>modport プロトタイプはmodport の識別子と各メンバーの識別子と方向を指定します。</p>
<pre><code class="language-veryl">proto interface ProtoA {
    var a: logic;
    var b: logic;

    modport mp {
        a: input ,
        b: output,
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="クロックドメインアノテーション"><a class="header" href="#クロックドメインアノテーション">クロックドメインアノテーション</a></h1>
<p>モジュール内に複数のクロックがある場合、<code>'a</code> のような明示的なクロックドメインアノテーションが必要です。アノテーションはそれぞれの信号がどのクロックドメインに所属するかを示します。</p>
<pre><code class="language-veryl playground">module ModuleA (
    // クロックドメイン 'a に所属
    i_clk_a: input  'a clock,
    i_dat_a: input  'a logic,
    o_dat_a: output 'a logic,

    // クロックドメイン 'b に所属
    i_clk_b: input  'b clock,
    i_dat_b: input  'b logic,
    o_dat_b: output 'b logic,
) {
    // 同じクロックドメイン内の代入は安全
    assign o_dat_a = i_dat_a;
    assign o_dat_b = i_dat_b;
}
</code></pre>
<p>モジュール内にクロックが1つしかない場合、アノテーションは省略できます。</p>
<pre><code class="language-veryl playground">module ModuleA (
    i_clk: input  clock,
    i_dat: input  logic,
    o_dat: output logic,
) {
    assign o_dat = i_dat;
}
</code></pre>
<p><code>'_</code> は暗黙のクロックドメインを表す特別なクロックドメインです。これは複数のクロックが同じ暗黙のクロックドメインに所属することを示すために使用できます。</p>
<pre><code class="language-veryl playground">module ModuleA (
    // 全ての信号は暗黙のクロックドメインに所属
    i_clk   : input  '_ clock,
    i_clk_x2: input  '_ clock,
    i_dat   : input     logic,
    o_dat   : output    logic,
) {
    assign o_dat = i_dat;
}
</code></pre>
<p>インターフェースインスタンスもクロックドメインアノテーションを指定可能です。</p>
<pre><code class="language-veryl playground">module ModuleA {
    inst intf: 'a InterfaceA;
}

interface InterfaceA {}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unsafe-cdc"><a class="header" href="#unsafe-cdc">Unsafe CDC</a></h1>
<p>Veryl コンパイラはクロックドメインクロッシングをエラーとして検出します。そのためクロックドメインクロッシングを行う場所には明示的な <code>unsafe (cdc)</code> ブロックが必要です。ブロック内ではクロックドメインクロッシングのチェックが抑制されるため、設計者はそれが安全かどうか注意深く確認する必要があります。</p>
<pre><code class="language-veryl playground">module ModuleA (
    i_clk_a: input  'a clock,
    i_dat_a: input  'a logic,
    i_clk_b: input  'b clock,
    o_dat_b: output 'b logic,
) {
    // エラー "Clock domain crossing is detected"
    //assign o_dat_b = i_dat_a;

    unsafe (cdc) {
        assign o_dat_b = i_dat_a;
    }
}
</code></pre>
<p>クロックドメイン境界には通常シンクロナイザセルが挿入されます。この場合も <code>unsafe (cdc)</code> ブロックが必要です。</p>
<pre><code class="language-veryl playground">module ModuleA (
    i_clk_a: input  'a clock,
    i_dat_a: input  'a logic,
    i_clk_b: input  'b clock,
    o_dat_b: output 'b logic,
) {
    unsafe (cdc) {
        inst u_sync: $sv::SynchronizerCell (
            i_clk: i_clk_b,
            i_dat: i_dat_a,
            o_dat: o_dat_b,
        );
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="標準ライブラリ"><a class="header" href="#標準ライブラリ">標準ライブラリ</a></h1>
<p>Verylはいくつかの便利な汎用モジュールを標準ライブラリとして提供しています。標準ライブラリは <code>$std</code> 名前空間にあり、依存関係を追加することなく使用できます。</p>
<div class="warning">
<p>標準ライブラリの公開APIは Veryl 1.0 がリリースされるまでは変更される可能性があります。</p>
</div>
<pre><code class="language-veryl">module ModuleA {
    // $std::fifo は標準ライブラリの FIFO モジュール
    inst u: $std::fifo (
        i_clk        : _,
        i_rst        : _,
        i_clear      : _,
        o_empty      : _,
        o_almost_full: _,
        o_full       : _,
        o_word_count : _,
        i_push       : _,
        i_data       : _,
        i_pop        : _,
        o_data       : _,
    );
}
</code></pre>
<p>標準ライブラリの完全なリストとドキュメントは <a href="https://std.veryl-lang.org">https://std.veryl-lang.org</a> にあります。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="エイリアス"><a class="header" href="#エイリアス">エイリアス</a></h1>
<p>ジェネリック引数を持つモジュール、インターフェース、パッケージの名前は非常に長くなる場合があります。<code>alias</code> はそのような要素に短い名前をつけることができます。</p>
<pre><code class="language-veryl playground">package PkgA::&lt;X: u32, Y: u32, Z: u32&gt; {}

alias package PkgA123 = PkgA::&lt;1, 2, 3&gt;;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="開発環境"><a class="header" href="#開発環境">開発環境</a></h1>
<p>この章ではプロジェクト設定や開発ツールなど開発環境について説明します。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="プロジェクト設定"><a class="header" href="#プロジェクト設定">プロジェクト設定</a></h1>
<ul>
<li><a href="06_development_environment/01_project_configuration.html#the-project-section"><code>[project]</code></a> — プロジェクト定義
<ul>
<li><a href="06_development_environment/01_project_configuration.html#the-name-field"><code>name</code></a> — プロジェクトの名前</li>
<li><a href="06_development_environment/01_project_configuration.html#the-version-field"><code>version</code></a> — プロジェクトのバージョン</li>
<li><a href="06_development_environment/01_project_configuration.html#the-authors-field"><code>authors</code></a> — プロジェクトの作者</li>
<li><a href="06_development_environment/01_project_configuration.html#the-description-field"><code>description</code></a> — プロジェクトの説明</li>
<li><a href="06_development_environment/01_project_configuration.html#the-license-field"><code>license</code></a> — プロジェクトのライセンス</li>
<li><a href="06_development_environment/01_project_configuration.html#the-repository-field"><code>repository</code></a> — プロジェクトのリポジトリの URL</li>
</ul>
</li>
<li><a href="06_development_environment/01_project_configuration.html#the-build-section"><code>[build]</code></a> — ビルド設定</li>
<li><a href="06_development_environment/01_project_configuration.html#the-format-section"><code>[format]</code></a> — フォーマット設定</li>
<li><a href="06_development_environment/01_project_configuration.html#the-lint-section"><code>[lint]</code></a> — リント設定</li>
<li><a href="06_development_environment/01_project_configuration.html#the-test-section"><code>[test]</code></a> — テスト設定</li>
<li><a href="06_development_environment/01_project_configuration.html#the-publish-section"><code>[publish]</code></a> — 公開設定</li>
<li><a href="06_development_environment/01_project_configuration.html#the-dependencies-section"><code>[dependencies]</code></a> — ライブラリの依存関係</li>
</ul>
<h2 id="the-project-section"><a class="header" href="#the-project-section"><code>[project]</code> セクション</a></h2>
<p><code>Veryl.toml</code> の最初のセクションは <code>[project]</code> です。<code>name</code> と <code>version</code> は必須です。</p>
<h3 id="the-name-field"><a class="header" href="#the-name-field"><code>name</code> フィールド</a></h3>
<p>プロジェクト名は生成されるコードのプレフィックスに使われます。そのためプロジェクト名はアルファベットか <code>_</code> で始まり、英数字と<code>_</code> しか使ってはいけません。</p>
<h3 id="the-version-field"><a class="header" href="#the-version-field"><code>version</code> フィールド</a></h3>
<p>プロジェクトのバージョンは <a href="https://semver.org/">セマンティックバージョニング</a>に従います。バージョンは以下の3つの数字からなります。</p>
<ul>
<li>メジャー – 互換性のない変更時に上げる</li>
<li>マイナー – 互換性のある機能追加時に上げる</li>
<li>バッチ – 互換性のあるバグ修正時に上げる</li>
</ul>
<pre><code class="language-toml">[project]
version = "0.1.0"
</code></pre>
<h3 id="the-authors-field"><a class="header" href="#the-authors-field"><code>authors</code> フィールド</a></h3>
<p>オプションの <code>authors</code> フィールドにはこのプロジェクトの作者である人や組織を配列にリストアップします。配列内の各文字列のフォーマットは自由です。名前のみ、Eメールアドレスのみ、名前と括弧で囲んだEメールアドレスといった形式がよく使われます。</p>
<pre><code class="language-toml">[project]
authors = ["Fnu Lnu", "anonymous@example.com", "Fnu Lnu &lt;anonymous@example.com&gt;"]
</code></pre>
<h3 id="the-description-field"><a class="header" href="#the-description-field"><code>description</code> フィールド</a></h3>
<p><code>description</code> はプロジェクトの短い説明です。マークダウンではなくプレーンテキスト形式で書きます。</p>
<h3 id="the-license-field"><a class="header" href="#the-license-field"><code>license</code> フィールド</a></h3>
<p><code>license</code> フィールドはこのプロジェクトがどのライセンスで公開されているかを指定します。指定する文字列は<a href="https://spdx.github.io/spdx-spec/v2.3/SPDX-license-expressions">SPDX 2.3 license expression</a>に従ってください。</p>
<pre><code class="language-toml">[project]
license = "MIT OR Apache-2.0"
</code></pre>
<h3 id="the-repository-field"><a class="header" href="#the-repository-field"><code>repository</code> フィールド</a></h3>
<p><code>repository</code> フィールドはプロジェクトのソースリポジトリへのURLです。</p>
<pre><code class="language-toml">[project]
repository = "https://github.com/veryl-lang/veryl"
</code></pre>
<h2 id="the-build-section"><a class="header" href="#the-build-section"><code>[build]</code> セクション</a></h2>
<p><code>[build]</code> セクションはコード生成の設定です。詳細は<a href="06_development_environment/./01_project_configuration/01_build.html">こちら</a>。</p>
<h2 id="the-format-section"><a class="header" href="#the-format-section"><code>[format]</code> セクション</a></h2>
<p><code>[format]</code> セクションはコードフォーマッターの設定です。詳細は<a href="06_development_environment/./01_project_configuration/02_format.html">こちら</a>。</p>
<h2 id="the-lint-section"><a class="header" href="#the-lint-section"><code>[lint]</code> セクション</a></h2>
<p><code>[lint]</code> セクションはリンタの設定です。詳細は<a href="06_development_environment/./01_project_configuration/03_lint.html">こちら</a>。</p>
<h2 id="the-test-section"><a class="header" href="#the-test-section"><code>[test]</code> セクション</a></h2>
<p><code>[test]</code> セクションはRTLシミュレータによるテストの設定です。詳細は<a href="06_development_environment/./01_project_configuration/04_test.html">こちら</a>。</p>
<h2 id="the-publish-section"><a class="header" href="#the-publish-section"><code>[publish]</code> セクション</a></h2>
<p><code>[publish]</code> セクションはプロジェクト公開の設定です。詳細は<a href="06_development_environment/./01_project_configuration/05_publish.html">こちら</a>。</p>
<h2 id="the-dependencies-section"><a class="header" href="#the-dependencies-section"><code>[dependencies]</code> セクション</a></h2>
<p><code>[dependencies]</code> セクションはライブラリの依存関係です。詳細は<a href="06_development_environment/./02_dependencies.html">こちら</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build"><a class="header" href="#build">Build</a></h1>
<p><code>[build]</code> セクションはコード生成の設定です。</p>
<h2 id="clock_type-フィールド"><a class="header" href="#clock_type-フィールド"><code>clock_type</code> フィールド</a></h2>
<p><code>clock_type</code> フィールドはフリップフロップを駆動するクロックエッジを指定します。</p>
<ul>
<li><code>posedge</code> – 立ち上がりエッジ</li>
<li><code>negedge</code> – 立ち下がりエッジ</li>
</ul>
<h2 id="reset_type-フィールド"><a class="header" href="#reset_type-フィールド"><code>reset_type</code> フィールド</a></h2>
<p><code>reset_type</code> フィールドはリセットの極性と同期性を指定します。</p>
<ul>
<li><code>async_low</code> – 非同期・負極性</li>
<li><code>async_high</code> – 非同期・正極性</li>
<li><code>sync_low</code> – 同期・負極性</li>
<li><code>sync_high</code> – 同期・正極性</li>
</ul>
<h2 id="filelist_type-フィールド"><a class="header" href="#filelist_type-フィールド"><code>filelist_type</code> フィールド</a></h2>
<p><code>filelist_type</code> フィールドはファイルリストのフォーマットを指定します。</p>
<ul>
<li><code>absolute</code> – プレーンテキスト形式の絶対パスのリスト</li>
<li><code>relative</code> – プレーンテキスト形式の相対パスのリスト</li>
<li><code>flgen</code> – <a href="https://github.com/pezy-computing/flgen">flgen</a> 形式のファイルリスト</li>
</ul>
<h2 id="sources-フィールド"><a class="header" href="#sources-フィールド"><code>sources</code> フィールド</a></h2>
<p>デフォルトではVerylコンパイラはプロジェクトルートから見える全ての <code>*.veryl</code> ファイルを処理します。特定のディレクトリだけを処理するために <code>sources</code> フィールドを使用することができます。</p>
<pre><code class="language-toml">[build]
sources = ["rtl/foo_module", "rtl/bar_module"]
</code></pre>
<p>上記の例では、Verylコンパイラは <code>rtl/foo_module</code> と <code>rtl/bar_module</code> の<code>*.veryl</code> ファイルを処理します。</p>
<h2 id="target-フィールド"><a class="header" href="#target-フィールド"><code>target</code> フィールド</a></h2>
<p><code>target</code> フィールドはコードの生成先を指定します。</p>
<ul>
<li><code>source</code> – ソースコードと同じディレクトリ</li>
<li><code>directory</code> – 特定のディレクトリ</li>
<li><code>bundle</code> – 特定のファイル</li>
</ul>
<p><code>directory</code> あるいは <code>bundle</code> を指定する場合は、ターゲットパスを <code>path</code> キーで指定します。</p>
<pre><code class="language-toml">[build]
target = {type = "directory", path = "[dst dir]"}
</code></pre>
<h2 id="implicit_parameter_types-フィールド"><a class="header" href="#implicit_parameter_types-フィールド"><code>implicit_parameter_types</code> フィールド</a></h2>
<p><code>implicit_parameter_types</code> フィールドは生成コードの <code>parameter</code> 宣言で省略する型をリストアップします。いくつかのEDAツールでは特定の型（例えば <code>string</code>）を <code>parameter</code> 宣言で使うことができないためです。例えば <code>string</code> を指定する場合は以下のようにします。</p>
<pre><code class="language-toml">[build]
implicit_parameter_types = ["string"]
</code></pre>
<h2 id="omit_project_prefix-フィールド"><a class="header" href="#omit_project_prefix-フィールド"><code>omit_project_prefix</code> フィールド</a></h2>
<p><code>omit_project_prefix</code> が <code>true</code> のとき、モジュール・インターフェース・パッケージ名のプロジェクトプレフィックスは省略されます。この値はデフォルトで <code>false</code> です。</p>
<pre><code class="language-toml">[build]
omit_project_prefix = true
</code></pre>
<h2 id="strip_comments-フィールド"><a class="header" href="#strip_comments-フィールド"><code>strip_comments</code> フィールド</a></h2>
<p><code>strip_comments</code> が <code>true</code> のとき、コメント出力は省略されます。この値はデフォルトで <code>false</code> です。</p>
<pre><code class="language-toml">[build]
strip_comments = true
</code></pre>
<h2 id="_prefix-と-_suffix-フィールド"><a class="header" href="#_prefix-と-_suffix-フィールド"><code>*_prefix</code> と <code>*_suffix</code> フィールド</a></h2>
<p><code>*_prefix</code> と <code>*_suffix</code> はコード生成時の追加のプレフィックスとサフィックスを指定します。指定可能な設定は以下の通りです。</p>
<ul>
<li><code>clock_posedge_prefix</code>: <code>clock_type = posedge</code> のときの <code>clock</code> 型のプレフィックス</li>
<li><code>clock_posedge_suffix</code>: <code>clock_type = posedge</code> のときの <code>clock</code> 型のサフィックス</li>
<li><code>clock_negedge_prefix</code>: <code>clock_type = negedge</code> のときの <code>clock</code> 型のプレフィックス</li>
<li><code>clock_negedge_suffix</code>: <code>clock_type = negedge</code> のときの <code>clock</code> 型のサフィックス</li>
<li><code>reset_high_prefix</code>: <code>reset_type = *_high</code> のときの <code>reset</code> 型のプレフィックス</li>
<li><code>reset_high_suffix</code>: <code>reset_type = *_high</code> のときの <code>reset</code> 型のサフィックス</li>
<li><code>reset_low_prefix</code>: <code>reset_type = *_low</code> のときの <code>reset</code> 型のプレフィックス</li>
<li><code>reset_low_suffix</code>: <code>reset_type = *_low</code> のときの <code>reset</code> 型のサフィックス</li>
</ul>
<h2 id="sourcemap-target"><a class="header" href="#sourcemap-target"><code>sourcemap_target</code> フィールド</a></h2>
<p><code>sourcemap_target</code> フィールドはソースマップの生成先を指定します。指定可能な設定は以下の通りです。</p>
<ul>
<li><code>target</code> – ターゲットコードと同じディレクトリ</li>
<li><code>directory</code> – 特定のディレクトリ</li>
<li><code>none</code> – ソースマップなし</li>
</ul>
<p><code>directory</code> を指定する場合は、ターゲットパスを <code>path</code> キーで指定します。</p>
<pre><code class="language-toml">[build]
sourcemap_target = {type = "directory", path = "[dst dir]"}
</code></pre>
<h2 id="expand_inside_operation-フィールド"><a class="header" href="#expand_inside_operation-フィールド"><code>expand_inside_operation</code> フィールド</a></h2>
<p><code>expand_inside_operation</code> が <code>true</code> のとき、<code>inside</code> 演算子を使った演算は<code>==?</code> 演算子を使った論理に展開されます。これはいくつかのEDAツールが<code>inside</code> 演算子をサポートしていないためです。この値はデフォルトで <code>false</code> です。</p>
<pre><code class="language-toml">[build]
expand_inside_operation = true
</code></pre>
<h2 id="hashed_mangled_name-フィールド"><a class="header" href="#hashed_mangled_name-フィールド"><code>hashed_mangled_name</code> フィールド</a></h2>
<p><code>hashed_mangled_name</code> が <code>true</code> のとき、出力されるコンポーネント名のうちジェネリック引数を示す部分がハッシュ化されます。この設定はジェネリック引数が多いときにマングリングされた名前が長くなりすぎるのを防ぎます。この値はデフォルトで <code>false</code> です。</p>
<pre><code class="language-toml">[build]
hashed_mangled_name = true
</code></pre>
<p>例:</p>
<ul>
<li>ハッシュ化されていない名前: <code>prj___PkgA__0__1__2__3</code></li>
<li>ハッシュ化された名前: <code>prj___PkgA__3894375d1deadabb</code></li>
</ul>
<h2 id="flatten_array_interface-フィールド"><a class="header" href="#flatten_array_interface-フィールド"><code>flatten_array_interface</code> フィールド</a></h2>
<p><code>flatten_array_interface</code> が <code>true</code> のとき、多次元の配列インスタンスやmodportは1次元に展開されます。この設定は多次元配列をサポートしていないEDAツールをサポートするためのものです。この値はデフォルトで <code>false</code> です。</p>
<pre><code class="language-toml">[build]
flatten_array_interface = true
</code></pre>
<p>例:</p>
<p>Veryl コード</p>
<pre><code class="language-veryl">module ModuleA (
    a_if: modport InterfaceA::mp [2, 3],
) {
    for i in 0..2 :g {
        for j in 0..3 :g {
            assign a_if[i][j].a = 0;
        }
    }
}
</code></pre>
<p><code>flatten_array_interface = true</code> で生成された SystemVerilog コード</p>
<pre><code class="language-verilog">module veryl_testcase_ModuleA (
    veryl_testcase_InterfaceA.mp a_if [0:(2)*(3)-1]
);
    for (genvar i = 0; i &lt; 2; i++) begin :g
        for (genvar j = 0; j &lt; 3; j++) begin :g
            always_comb a_if[(i)*(3)+(j)].a = 0;
        end
    end
endmodule
</code></pre>
<h2 id="exclude_std-フィールド"><a class="header" href="#exclude_std-フィールド"><code>exclude_std</code> フィールド</a></h2>
<p><code>exclude_std</code> が <code>true</code> のとき、標準ライブラリはインクルードされません。</p>
<pre><code class="language-toml">[build]
exclude_std = true
</code></pre>
<h2 id="emit_cond_type-フィールド"><a class="header" href="#emit_cond_type-フィールド"><code>emit_cond_type</code> フィールド</a></h2>
<p><code>emit_cond_type</code> が <code>true</code> のとき、<code>unique</code> <code>unique0</code> <code>priority</code> といった指定が出力されます。</p>
<pre><code class="language-toml">[build]
emit_cond_type = true
</code></pre>
<h2 id="instance_depth_limit-フィールド"><a class="header" href="#instance_depth_limit-フィールド"><code>instance_depth_limit</code> フィールド</a></h2>
<p><code>instance_depth_limit</code> はインスタンス階層の最大深さです。デフォルト値は 128 です。</p>
<pre><code class="language-toml">[build]
instance_depth_limit = 256
</code></pre>
<h2 id="instance_total_limi-フィールド"><a class="header" href="#instance_total_limi-フィールド"><code>instance_total_limi</code> フィールド</a></h2>
<p><code>instance_total_limit</code> は1つのモジュール内のサブインスタンスの最大数です。デフォルト値は 1048576 です。</p>
<pre><code class="language-toml">[build]
instance_total_limit = 256
</code></pre>
<h2 id="incremental-フィールド"><a class="header" href="#incremental-フィールド"><code>incremental</code> フィールド</a></h2>
<p><code>incremental</code> が <code>true</code> のとき、Verylコンパイラは更新されたファイルに関連したファイルのみを再生成します。デフォルト値は <code>false</code> です。</p>
<pre><code class="language-toml">[build]
incremental = true
</code></pre>
<h2 id="error_count_limit-フィールド"><a class="header" href="#error_count_limit-フィールド"><code>error_count_limit</code> フィールド</a></h2>
<p>表示するエラーメッセージの最大数を指定します。全てのメッセージを表示するにはフィールドを設定しないか、0を指定します。</p>
<pre><code class="language-toml">[build]
error_count_limit = 10
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="format"><a class="header" href="#format">Format</a></h1>
<p><code>[format]</code> セクションはフォーマッタの設定です。</p>
<pre><code class="language-toml">[format]
indent_width = 4
</code></pre>
<h2 id="設定"><a class="header" href="#設定">設定</a></h2>
<div class="table-wrapper"><table><thead><tr><th>設定</th><th>設定値</th><th>デフォルト</th><th>説明</th></tr></thead><tbody>
<tr><td>indent_width</td><td>整数</td><td>4</td><td>インデントのスペース幅</td></tr>
<tr><td>vertical_align</td><td>ブーリアン</td><td>true</td><td>垂直方向の調整を有効にする</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="lint"><a class="header" href="#lint">Lint</a></h1>
<p><code>[lint]</code> セクションはリンターの設定です。</p>
<pre><code class="language-toml">[lint.naming]
case_enum = "snake"
</code></pre>
<h2 id="設定-1"><a class="header" href="#設定-1">設定</a></h2>
<h3 id="lintnaming-セクション"><a class="header" href="#lintnaming-セクション"><code>[lint.naming]</code> セクション</a></h3>
<p>このセクションは命名規則の設定です。</p>
<div class="table-wrapper"><table><thead><tr><th>設定</th><th>設定値</th><th>説明</th></tr></thead><tbody>
<tr><td>case_enum</td><td>ケースタイプ<sup class="footnote-reference" id="fr-casetype-1"><a href="#footnote-casetype">1</a></sup></td><td><code>enum</code> のケーススタイル</td></tr>
<tr><td>case_function</td><td>ケースタイプ<sup class="footnote-reference" id="fr-casetype-2"><a href="#footnote-casetype">1</a></sup></td><td><code>function</code> のケーススタイル</td></tr>
<tr><td>case_function_inout</td><td>ケースタイプ<sup class="footnote-reference" id="fr-casetype-3"><a href="#footnote-casetype">1</a></sup></td><td><code>inout</code> 引数のケーススタイル</td></tr>
<tr><td>case_function_input</td><td>ケースタイプ<sup class="footnote-reference" id="fr-casetype-4"><a href="#footnote-casetype">1</a></sup></td><td><code>input</code> 引数のケーススタイル</td></tr>
<tr><td>case_function_output</td><td>ケースタイプ<sup class="footnote-reference" id="fr-casetype-5"><a href="#footnote-casetype">1</a></sup></td><td><code>output</code> 引数のケーススタイル</td></tr>
<tr><td>case_instance</td><td>ケースタイプ<sup class="footnote-reference" id="fr-casetype-6"><a href="#footnote-casetype">1</a></sup></td><td>インスタンスのケーススタイル</td></tr>
<tr><td>case_interface</td><td>ケースタイプ<sup class="footnote-reference" id="fr-casetype-7"><a href="#footnote-casetype">1</a></sup></td><td><code>interface</code> のケーススタイル</td></tr>
<tr><td>case_modport</td><td>ケースタイプ<sup class="footnote-reference" id="fr-casetype-8"><a href="#footnote-casetype">1</a></sup></td><td><code>modport</code> のケーススタイル</td></tr>
<tr><td>case_module</td><td>ケースタイプ<sup class="footnote-reference" id="fr-casetype-9"><a href="#footnote-casetype">1</a></sup></td><td><code>module</code> のケーススタイル</td></tr>
<tr><td>case_package</td><td>ケースタイプ<sup class="footnote-reference" id="fr-casetype-10"><a href="#footnote-casetype">1</a></sup></td><td><code>package</code> のケーススタイル</td></tr>
<tr><td>case_parameter</td><td>ケースタイプ<sup class="footnote-reference" id="fr-casetype-11"><a href="#footnote-casetype">1</a></sup></td><td><code>parameter</code> のケーススタイル</td></tr>
<tr><td>case_port_inout</td><td>ケースタイプ<sup class="footnote-reference" id="fr-casetype-12"><a href="#footnote-casetype">1</a></sup></td><td><code>inout</code> ポートのケーススタイル</td></tr>
<tr><td>case_port_input</td><td>ケースタイプ<sup class="footnote-reference" id="fr-casetype-13"><a href="#footnote-casetype">1</a></sup></td><td><code>input</code> ポートのケーススタイル</td></tr>
<tr><td>case_port_modport</td><td>ケースタイプ<sup class="footnote-reference" id="fr-casetype-14"><a href="#footnote-casetype">1</a></sup></td><td><code>modport</code> ポートのケーススタイル</td></tr>
<tr><td>case_port_output</td><td>ケースタイプ<sup class="footnote-reference" id="fr-casetype-15"><a href="#footnote-casetype">1</a></sup></td><td><code>output</code> ポートのケーススタイル</td></tr>
<tr><td>case_reg</td><td>ケースタイプ<sup class="footnote-reference" id="fr-casetype-16"><a href="#footnote-casetype">1</a></sup></td><td>レジスタ変数<sup class="footnote-reference" id="fr-reg-1"><a href="#footnote-reg">2</a></sup>のケーススタイル</td></tr>
<tr><td>case_struct</td><td>ケースタイプ<sup class="footnote-reference" id="fr-casetype-17"><a href="#footnote-casetype">1</a></sup></td><td><code>struct</code> のケーススタイル</td></tr>
<tr><td>case_union</td><td>ケースタイプ<sup class="footnote-reference" id="fr-casetype-18"><a href="#footnote-casetype">1</a></sup></td><td><code>union</code> のケーススタイル</td></tr>
<tr><td>case_var</td><td>ケースタイプ<sup class="footnote-reference" id="fr-casetype-19"><a href="#footnote-casetype">1</a></sup></td><td>変数のケーススタイル</td></tr>
<tr><td>case_wire</td><td>ケースタイプ<sup class="footnote-reference" id="fr-casetype-20"><a href="#footnote-casetype">1</a></sup></td><td>ワイヤ変数<sup class="footnote-reference" id="fr-wire-1"><a href="#footnote-wire">3</a></sup>のケーススタイル</td></tr>
<tr><td>prefix_enum</td><td>文字列</td><td><code>enum</code> のプレフィックス</td></tr>
<tr><td>prefix_function</td><td>文字列</td><td><code>function</code> のプレフィックス</td></tr>
<tr><td>prefix_function_inout</td><td>文字列</td><td><code>inout</code> 引数のプレフィックス</td></tr>
<tr><td>prefix_function_input</td><td>文字列</td><td><code>input</code> 引数のプレフィックス</td></tr>
<tr><td>prefix_function_output</td><td>文字列</td><td><code>output</code> 引数のプレフィックス</td></tr>
<tr><td>prefix_instance</td><td>文字列</td><td>インスタンスのプレフィックス</td></tr>
<tr><td>prefix_interface</td><td>文字列</td><td><code>interface</code> のプレフィックス</td></tr>
<tr><td>prefix_modport</td><td>文字列</td><td><code>modport</code> のプレフィックス</td></tr>
<tr><td>prefix_module</td><td>文字列</td><td><code>module</code> のプレフィックス</td></tr>
<tr><td>prefix_package</td><td>文字列</td><td><code>package</code> のプレフィックス</td></tr>
<tr><td>prefix_parameter</td><td>文字列</td><td><code>parameter</code> のプレフィックス</td></tr>
<tr><td>prefix_port_inout</td><td>文字列</td><td><code>inout</code> ポートのプレフィックス</td></tr>
<tr><td>prefix_port_input</td><td>文字列</td><td><code>input</code> ポートのプレフィックス</td></tr>
<tr><td>prefix_port_modport</td><td>文字列</td><td><code>modport</code> ポートのプレフィックス</td></tr>
<tr><td>prefix_port_output</td><td>文字列</td><td><code>output</code> ポートのプレフィックス</td></tr>
<tr><td>prefix_reg</td><td>文字列</td><td>レジスタ変数<sup class="footnote-reference" id="fr-reg-2"><a href="#footnote-reg">2</a></sup>のプレフィックス</td></tr>
<tr><td>prefix_struct</td><td>文字列</td><td><code>struct</code> のプレフィックス</td></tr>
<tr><td>prefix_union</td><td>文字列</td><td><code>union</code> のプレフィックス</td></tr>
<tr><td>prefix_var</td><td>文字列</td><td>変数のプレフィックス</td></tr>
<tr><td>prefix_wire</td><td>文字列</td><td>ワイヤ変数<sup class="footnote-reference" id="fr-wire-2"><a href="#footnote-wire">3</a></sup>のプレフィックス</td></tr>
<tr><td>suffix_enum</td><td>文字列</td><td><code>enum</code> のサフィックス</td></tr>
<tr><td>suffix_function</td><td>文字列</td><td><code>function</code> のサフィックス</td></tr>
<tr><td>suffix_function_inout</td><td>文字列</td><td><code>inout</code> 引数のサフィックス</td></tr>
<tr><td>suffix_function_input</td><td>文字列</td><td><code>input</code> 引数のサフィックス</td></tr>
<tr><td>suffix_function_output</td><td>文字列</td><td><code>output</code> 引数のサフィックス</td></tr>
<tr><td>suffix_instance</td><td>文字列</td><td>インスタンスのサフィックス</td></tr>
<tr><td>suffix_interface</td><td>文字列</td><td><code>interface</code> のサフィックス</td></tr>
<tr><td>suffix_modport</td><td>文字列</td><td><code>modport</code> のサフィックス</td></tr>
<tr><td>suffix_module</td><td>文字列</td><td><code>module</code> のサフィックス</td></tr>
<tr><td>suffix_package</td><td>文字列</td><td><code>package</code> のサフィックス</td></tr>
<tr><td>suffix_parameter</td><td>文字列</td><td><code>parameter</code> のサフィックス</td></tr>
<tr><td>suffix_port_inout</td><td>文字列</td><td><code>inout</code> ポートのサフィックス</td></tr>
<tr><td>suffix_port_input</td><td>文字列</td><td><code>input</code> ポートのサフィックス</td></tr>
<tr><td>suffix_port_modport</td><td>文字列</td><td><code>modport</code> ポートのサフィックス</td></tr>
<tr><td>suffix_port_output</td><td>文字列</td><td><code>output</code> ポートのサフィックス</td></tr>
<tr><td>suffix_reg</td><td>文字列</td><td>レジスタ変数<sup class="footnote-reference" id="fr-reg-3"><a href="#footnote-reg">2</a></sup>のサフィックス</td></tr>
<tr><td>suffix_struct</td><td>文字列</td><td><code>struct</code> のサフィックス</td></tr>
<tr><td>suffix_union</td><td>文字列</td><td><code>union</code> のサフィックス</td></tr>
<tr><td>suffix_var</td><td>文字列</td><td>変数のサフィックス</td></tr>
<tr><td>suffix_wire</td><td>文字列</td><td>ワイヤ変数<sup class="footnote-reference" id="fr-wire-3"><a href="#footnote-wire">3</a></sup>のサフィックス</td></tr>
<tr><td>re_forbidden_enum</td><td>正規表現<sup class="footnote-reference" id="fr-regex-1"><a href="#footnote-regex">4</a></sup></td><td><code>enum</code> の禁止正規表現</td></tr>
<tr><td>re_forbidden_function</td><td>正規表現<sup class="footnote-reference" id="fr-regex-2"><a href="#footnote-regex">4</a></sup></td><td><code>function</code> の禁止正規表現</td></tr>
<tr><td>re_forbidden_function_inout</td><td>正規表現<sup class="footnote-reference" id="fr-regex-3"><a href="#footnote-regex">4</a></sup></td><td><code>inout</code> 引数の禁止正規表現</td></tr>
<tr><td>re_forbidden_function_input</td><td>正規表現<sup class="footnote-reference" id="fr-regex-4"><a href="#footnote-regex">4</a></sup></td><td><code>input</code> 引数の禁止正規表現</td></tr>
<tr><td>re_forbidden_function_output</td><td>正規表現<sup class="footnote-reference" id="fr-regex-5"><a href="#footnote-regex">4</a></sup></td><td><code>output</code> 引数の禁止正規表現</td></tr>
<tr><td>re_forbidden_instance</td><td>正規表現<sup class="footnote-reference" id="fr-regex-6"><a href="#footnote-regex">4</a></sup></td><td>インスタンスの禁止正規表現</td></tr>
<tr><td>re_forbidden_interface</td><td>正規表現<sup class="footnote-reference" id="fr-regex-7"><a href="#footnote-regex">4</a></sup></td><td><code>interface</code> の禁止正規表現</td></tr>
<tr><td>re_forbidden_modport</td><td>正規表現<sup class="footnote-reference" id="fr-regex-8"><a href="#footnote-regex">4</a></sup></td><td><code>modport</code> の禁止正規表現</td></tr>
<tr><td>re_forbidden_module</td><td>正規表現<sup class="footnote-reference" id="fr-regex-9"><a href="#footnote-regex">4</a></sup></td><td><code>module</code> の禁止正規表現</td></tr>
<tr><td>re_forbidden_package</td><td>正規表現<sup class="footnote-reference" id="fr-regex-10"><a href="#footnote-regex">4</a></sup></td><td><code>package</code> の禁止正規表現</td></tr>
<tr><td>re_forbidden_parameter</td><td>正規表現<sup class="footnote-reference" id="fr-regex-11"><a href="#footnote-regex">4</a></sup></td><td><code>parameter</code> の禁止正規表現</td></tr>
<tr><td>re_forbidden_port_inout</td><td>正規表現<sup class="footnote-reference" id="fr-regex-12"><a href="#footnote-regex">4</a></sup></td><td><code>inout</code> ポートの禁止正規表現</td></tr>
<tr><td>re_forbidden_port_input</td><td>正規表現<sup class="footnote-reference" id="fr-regex-13"><a href="#footnote-regex">4</a></sup></td><td><code>input</code> ポートの禁止正規表現</td></tr>
<tr><td>re_forbidden_port_modport</td><td>正規表現<sup class="footnote-reference" id="fr-regex-14"><a href="#footnote-regex">4</a></sup></td><td><code>modport</code> ポートの禁止正規表現</td></tr>
<tr><td>re_forbidden_port_output</td><td>正規表現<sup class="footnote-reference" id="fr-regex-15"><a href="#footnote-regex">4</a></sup></td><td><code>output</code> ポートの禁止正規表現</td></tr>
<tr><td>re_forbidden_reg</td><td>正規表現<sup class="footnote-reference" id="fr-regex-16"><a href="#footnote-regex">4</a></sup></td><td>レジスタ変数<sup class="footnote-reference" id="fr-reg-4"><a href="#footnote-reg">2</a></sup>の禁止正規表現</td></tr>
<tr><td>re_forbidden_struct</td><td>正規表現<sup class="footnote-reference" id="fr-regex-17"><a href="#footnote-regex">4</a></sup></td><td><code>struct</code> の禁止正規表現</td></tr>
<tr><td>re_forbidden_union</td><td>正規表現<sup class="footnote-reference" id="fr-regex-18"><a href="#footnote-regex">4</a></sup></td><td><code>union</code> の禁止正規表現</td></tr>
<tr><td>re_forbidden_var</td><td>正規表現<sup class="footnote-reference" id="fr-regex-19"><a href="#footnote-regex">4</a></sup></td><td>変数の禁止正規表現</td></tr>
<tr><td>re_forbidden_wire</td><td>正規表現<sup class="footnote-reference" id="fr-regex-20"><a href="#footnote-regex">4</a></sup></td><td>ワイヤ変数<sup class="footnote-reference" id="fr-wire-4"><a href="#footnote-wire">3</a></sup>の禁止正規表現</td></tr>
<tr><td>re_required_enum</td><td>正規表現<sup class="footnote-reference" id="fr-regex-21"><a href="#footnote-regex">4</a></sup></td><td><code>enum</code> の必須正規表現</td></tr>
<tr><td>re_required_function</td><td>正規表現<sup class="footnote-reference" id="fr-regex-22"><a href="#footnote-regex">4</a></sup></td><td><code>function</code> の必須正規表現</td></tr>
<tr><td>re_required_function_inout</td><td>正規表現<sup class="footnote-reference" id="fr-regex-23"><a href="#footnote-regex">4</a></sup></td><td><code>inout</code> 引数の必須正規表現</td></tr>
<tr><td>re_required_function_input</td><td>正規表現<sup class="footnote-reference" id="fr-regex-24"><a href="#footnote-regex">4</a></sup></td><td><code>input</code> 引数の必須正規表現</td></tr>
<tr><td>re_required_function_output</td><td>正規表現<sup class="footnote-reference" id="fr-regex-25"><a href="#footnote-regex">4</a></sup></td><td><code>output</code> 引数の必須正規表現</td></tr>
<tr><td>re_required_instance</td><td>正規表現<sup class="footnote-reference" id="fr-regex-26"><a href="#footnote-regex">4</a></sup></td><td>インスタンスの必須正規表現</td></tr>
<tr><td>re_required_interface</td><td>正規表現<sup class="footnote-reference" id="fr-regex-27"><a href="#footnote-regex">4</a></sup></td><td><code>interface</code> の必須正規表現</td></tr>
<tr><td>re_required_modport</td><td>正規表現<sup class="footnote-reference" id="fr-regex-28"><a href="#footnote-regex">4</a></sup></td><td><code>modport</code> の必須正規表現</td></tr>
<tr><td>re_required_module</td><td>正規表現<sup class="footnote-reference" id="fr-regex-29"><a href="#footnote-regex">4</a></sup></td><td><code>module</code> の必須正規表現</td></tr>
<tr><td>re_required_package</td><td>正規表現<sup class="footnote-reference" id="fr-regex-30"><a href="#footnote-regex">4</a></sup></td><td><code>package</code> の必須正規表現</td></tr>
<tr><td>re_required_parameter</td><td>正規表現<sup class="footnote-reference" id="fr-regex-31"><a href="#footnote-regex">4</a></sup></td><td><code>parameter</code> の必須正規表現</td></tr>
<tr><td>re_required_port_inout</td><td>正規表現<sup class="footnote-reference" id="fr-regex-32"><a href="#footnote-regex">4</a></sup></td><td><code>inout</code> ポートの必須正規表現</td></tr>
<tr><td>re_required_port_input</td><td>正規表現<sup class="footnote-reference" id="fr-regex-33"><a href="#footnote-regex">4</a></sup></td><td><code>input</code> ポートの必須正規表現</td></tr>
<tr><td>re_required_port_modport</td><td>正規表現<sup class="footnote-reference" id="fr-regex-34"><a href="#footnote-regex">4</a></sup></td><td><code>modport</code> ポートの必須正規表現</td></tr>
<tr><td>re_required_port_output</td><td>正規表現<sup class="footnote-reference" id="fr-regex-35"><a href="#footnote-regex">4</a></sup></td><td><code>output</code> ポートの必須正規表現</td></tr>
<tr><td>re_required_reg</td><td>正規表現<sup class="footnote-reference" id="fr-regex-36"><a href="#footnote-regex">4</a></sup></td><td>レジスタ変数<sup class="footnote-reference" id="fr-reg-5"><a href="#footnote-reg">2</a></sup>の必須正規表現</td></tr>
<tr><td>re_required_struct</td><td>正規表現<sup class="footnote-reference" id="fr-regex-37"><a href="#footnote-regex">4</a></sup></td><td><code>struct</code> の必須正規表現</td></tr>
<tr><td>re_required_union</td><td>正規表現<sup class="footnote-reference" id="fr-regex-38"><a href="#footnote-regex">4</a></sup></td><td><code>union</code> の必須正規表現</td></tr>
<tr><td>re_required_var</td><td>正規表現<sup class="footnote-reference" id="fr-regex-39"><a href="#footnote-regex">4</a></sup></td><td>変数の必須正規表現</td></tr>
<tr><td>re_required_wire</td><td>正規表現<sup class="footnote-reference" id="fr-regex-40"><a href="#footnote-regex">4</a></sup></td><td>ワイヤ変数<sup class="footnote-reference" id="fr-wire-5"><a href="#footnote-wire">3</a></sup>の必須正規表現</td></tr>
</tbody></table>
</div>
<ul>
<li><code>"snake"</code> – snake_case</li>
<li><code>"screaming_snake"</code> – SCREAMING_SNAKE_CASE</li>
<li><code>"lower_camel"</code> – lowerCamelCase</li>
<li><code>"upper_camel"</code> – UpperCamelCase</li>
</ul>
<hr>
<ol class="footnote-definition"><li id="footnote-casetype">
<p>設定可能な値は以下です。 <a href="#fr-casetype-1">↩</a> <a href="#fr-casetype-2">↩2</a> <a href="#fr-casetype-3">↩3</a> <a href="#fr-casetype-4">↩4</a> <a href="#fr-casetype-5">↩5</a> <a href="#fr-casetype-6">↩6</a> <a href="#fr-casetype-7">↩7</a> <a href="#fr-casetype-8">↩8</a> <a href="#fr-casetype-9">↩9</a> <a href="#fr-casetype-10">↩10</a> <a href="#fr-casetype-11">↩11</a> <a href="#fr-casetype-12">↩12</a> <a href="#fr-casetype-13">↩13</a> <a href="#fr-casetype-14">↩14</a> <a href="#fr-casetype-15">↩15</a> <a href="#fr-casetype-16">↩16</a> <a href="#fr-casetype-17">↩17</a> <a href="#fr-casetype-18">↩18</a> <a href="#fr-casetype-19">↩19</a> <a href="#fr-casetype-20">↩20</a></p>
</li>
<li id="footnote-reg">
<p>レジスタ変数とは <code>always_ff</code> で代入される変数です。合成フェーズでフリップフロップにマップされます。 <a href="#fr-reg-1">↩</a> <a href="#fr-reg-2">↩2</a> <a href="#fr-reg-3">↩3</a> <a href="#fr-reg-4">↩4</a> <a href="#fr-reg-5">↩5</a></p>
</li>
<li id="footnote-wire">
<p>ワイヤ変数とは <code>always_comb</code> で代入される変数です。合成フェーズでワイヤにマップされます。 <a href="#fr-wire-1">↩</a> <a href="#fr-wire-2">↩2</a> <a href="#fr-wire-3">↩3</a> <a href="#fr-wire-4">↩4</a> <a href="#fr-wire-5">↩5</a></p>
</li>
<li id="footnote-regex">
<p><code>".*"</code>のような正規表現です。使用可能な構文は<a href="https://docs.rs/regex/latest/regex/#syntax">こちら</a>. <a href="#fr-regex-1">↩</a> <a href="#fr-regex-2">↩2</a> <a href="#fr-regex-3">↩3</a> <a href="#fr-regex-4">↩4</a> <a href="#fr-regex-5">↩5</a> <a href="#fr-regex-6">↩6</a> <a href="#fr-regex-7">↩7</a> <a href="#fr-regex-8">↩8</a> <a href="#fr-regex-9">↩9</a> <a href="#fr-regex-10">↩10</a> <a href="#fr-regex-11">↩11</a> <a href="#fr-regex-12">↩12</a> <a href="#fr-regex-13">↩13</a> <a href="#fr-regex-14">↩14</a> <a href="#fr-regex-15">↩15</a> <a href="#fr-regex-16">↩16</a> <a href="#fr-regex-17">↩17</a> <a href="#fr-regex-18">↩18</a> <a href="#fr-regex-19">↩19</a> <a href="#fr-regex-20">↩20</a> <a href="#fr-regex-21">↩21</a> <a href="#fr-regex-22">↩22</a> <a href="#fr-regex-23">↩23</a> <a href="#fr-regex-24">↩24</a> <a href="#fr-regex-25">↩25</a> <a href="#fr-regex-26">↩26</a> <a href="#fr-regex-27">↩27</a> <a href="#fr-regex-28">↩28</a> <a href="#fr-regex-29">↩29</a> <a href="#fr-regex-30">↩30</a> <a href="#fr-regex-31">↩31</a> <a href="#fr-regex-32">↩32</a> <a href="#fr-regex-33">↩33</a> <a href="#fr-regex-34">↩34</a> <a href="#fr-regex-35">↩35</a> <a href="#fr-regex-36">↩36</a> <a href="#fr-regex-37">↩37</a> <a href="#fr-regex-38">↩38</a> <a href="#fr-regex-39">↩39</a> <a href="#fr-regex-40">↩40</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="test"><a class="header" href="#test">Test</a></h1>
<p><code>[test]</code> セクションは以下のように組み込みユニットテストの設定を指定します。</p>
<pre><code class="language-toml">[test]
simulator = "vcs"
</code></pre>
<h2 id="設定-2"><a class="header" href="#設定-2">設定</a></h2>
<h2 id="test-セクション"><a class="header" href="#test-セクション"><code>[test]</code> セクション</a></h2>
<h3 id="simulator-フィールド"><a class="header" href="#simulator-フィールド"><code>simulator</code> フィールド</a></h3>
<p><code>simulator</code> フィールドはデフォルトのシミュレータを指定します。以下のタイプを指定できます。</p>
<ul>
<li><code>"verilator"</code></li>
<li><code>"vcs"</code></li>
<li><code>"dsim"</code></li>
<li><code>"vivado"</code></li>
</ul>
<h3 id="include_files-フィールド"><a class="header" href="#include_files-フィールド"><code>include_files</code> フィールド</a></h3>
<p><code>include_files</code> フィールドはシミュレーションに使う追加のファイルを指定します。</p>
<pre><code class="language-toml">[test]
include_files = ["test/mem.hex"]
</code></pre>
<h3 id="waveform_target-フィールド"><a class="header" href="#waveform_target-フィールド"><code>waveform_target</code> フィールド</a></h3>
<p><code>waveform_target</code> フィールドは波形の生成先を指定します。</p>
<ul>
<li><code>target</code> – ターゲットコードと同じディレクトリ</li>
<li><code>directory</code> – 特定のディレクトリ</li>
</ul>
<p><code>directory</code> を指定する場合は、ターゲットパスを <code>path</code> キーで指定します。</p>
<pre><code class="language-toml">[test]
waveform_target = {type = "directory", path = "[dst dir]"}
</code></pre>
<h3 id="waveform_format-フィールド"><a class="header" href="#waveform_format-フィールド"><code>waveform_format</code> フィールド</a></h3>
<p><code>waveform_format</code> フィールドはダンプされる波形のフォーマットを指定します。指定できる値は以下の通りです。</p>
<ul>
<li><code>vcd</code> – デフォルト値であり、多くのベンダーでサポートされていますが機能は限定的です。</li>
<li><code>fst</code> – 整数の代わりにenum値を表示するなどいくつかの機能をサポートしています。<code>gtkwave</code> と <code>surfer</code> で扱うことができます。</li>
</ul>
<h2 id="testverilator-セクション"><a class="header" href="#testverilator-セクション"><code>[test.verilator]</code> セクション</a></h2>
<p>このセクションはVerilatorによるテストの設定です。</p>
<div class="table-wrapper"><table><thead><tr><th>設定</th><th>設定値</th><th>説明</th></tr></thead><tbody>
<tr><td>compile_args</td><td>[文字列]</td><td><code>verilator</code> コマンドへの追加の引数</td></tr>
<tr><td>simulate_args</td><td>[文字列]</td><td>シミュレーションバイナリへの追加の引数</td></tr>
</tbody></table>
</div>
<h2 id="testvcs-セクション"><a class="header" href="#testvcs-セクション"><code>[test.vcs]</code> セクション</a></h2>
<p>このセクションはVCSによるテストの設定です。</p>
<div class="table-wrapper"><table><thead><tr><th>設定</th><th>設定値</th><th>説明</th></tr></thead><tbody>
<tr><td>compile_args</td><td>[文字列]</td><td><code>vcs</code> コマンドへの追加の引数</td></tr>
<tr><td>simulate_args</td><td>[文字列]</td><td>シミュレーションバイナリへの追加の引数</td></tr>
</tbody></table>
</div>
<h2 id="testdsim-セクション"><a class="header" href="#testdsim-セクション"><code>[test.dsim]</code> セクション</a></h2>
<p>このセクションはDSimによるテストの設定です。</p>
<div class="table-wrapper"><table><thead><tr><th>設定</th><th>設定値</th><th>説明</th></tr></thead><tbody>
<tr><td>compile_args</td><td>[文字列]</td><td><code>dsim</code> コマンドへの追加の引数</td></tr>
<tr><td>simulate_args</td><td>[文字列]</td><td><code>dsim</code> コマンドへの追加の引数</td></tr>
</tbody></table>
</div>
<h2 id="testvivado-セクション"><a class="header" href="#testvivado-セクション"><code>[test.vivado]</code> セクション</a></h2>
<p>このセクションはVivadoによるテストの設定です。</p>
<div class="table-wrapper"><table><thead><tr><th>設定</th><th>設定値</th><th>説明</th></tr></thead><tbody>
<tr><td>compile_args</td><td>[文字列]</td><td><code>xvlog</code> コマンドへの追加の引数</td></tr>
<tr><td>elaborate_args</td><td>[文字列]</td><td><code>xelab</code> コマンドへの追加の引数</td></tr>
<tr><td>simulate_args</td><td>[文字列]</td><td><code>xsim</code> コマンドへの追加の引数</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="publish"><a class="header" href="#publish">Publish</a></h1>
<p><code>[publish]</code> セクションは以下のようにプロジェクト公開の設定を指定します。</p>
<pre><code class="language-toml">[publish]
bump_commit = true
bump_commit_message = "Bump"
</code></pre>
<h3 id="設定-3"><a class="header" href="#設定-3">設定</a></h3>
<div class="table-wrapper"><table><thead><tr><th>設定</th><th>設定値</th><th>デフォルト</th><th>説明</th></tr></thead><tbody>
<tr><td>bump_commit</td><td>ブーリアン</td><td>false</td><td>バージョンアップ後の自動コミット</td></tr>
<tr><td>publish_commit</td><td>ブーリアン</td><td>false</td><td>公開後の自動コミット</td></tr>
<tr><td>bump_commit_mesasge</td><td>文字列</td><td>“chore: Bump version”</td><td>バージョンアップ後のコミットメッセージ</td></tr>
<tr><td>publish_commit_mesasge</td><td>文字列</td><td>“chore: Publish”</td><td>公開後のコミットメッセージ</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="依存関係"><a class="header" href="#依存関係">依存関係</a></h1>
<p>他の Veryl プロジェクトへの依存関係をプロジェクトに追加したい場合、<code>Veryl.toml</code> に <code>[dependencies]</code> セクションを追加します。エントリの左辺は依存関係のプロジェクト名、右辺はソースパスとバージョンです。<code>github</code> はGitHub上のリポジトリを参照する糖衣構文です。代わりに <code>git</code> を用いてURL全体を指定することもできます。</p>
<pre><code class="language-toml">[dependencies]
veryl_sample = {github = "veryl-lang/veryl_sample", version = "0.1.0"}

# これは上記と同じ
veryl_sample = {git = "https://github.com/veryl-lang/veryl_sample", version = "0.1.0"}
</code></pre>
<p>デフォルトでは依存関係の名前空間はそのプロジェクト名と同じです。もし左辺の名前を変更した場合は、<code>project</code> フィールドでプロジェクト名を指定する必要があります。</p>
<pre><code class="language-toml">[dependencies]
veryl_sample_alt = {github = "veryl-lang/veryl_sample", project = "veryl_sample", version = "0.2.0"}
</code></pre>
<p>リポジトリの内部プロジェクトは以下のように指定できます。</p>
<pre><code class="language-toml">[dependencies]
inner_prj1 = {github = "veryl-lang/veryl_sample", version = "0.1.0"}
inner_prj2 = {github = "veryl-lang/veryl_sample", version = "0.1.0"}
inner_prj3 = {github = "veryl-lang/veryl_sample", version = "0.1.0"}
</code></pre>
<h2 id="依存関係の使用"><a class="header" href="#依存関係の使用">依存関係の使用</a></h2>
<p><code>Veryl.toml</code> に依存関係を追加したあとは、その依存関係の <code>module</code>、<code>interface</code>、<code>package</code>を使うことができます。以下は <code>veryl_sample</code> の依存関係に含まれる <code>delay</code> モジュールを使った例です。</p>
<pre><code class="language-veryl">module ModuleA (
    i_clk: input  clock,
    i_rst: input  reset,
    i_d  : input  logic,
    o_d  : output logic,
) {
    inst u_delay: veryl_sample::delay (
        i_clk,
        i_rst,
        i_d  ,
        o_d  ,
    );
}
</code></pre>
<blockquote>
<p>注：上記のコードのプレイボタンの結果は依存関係解決を行わないので正確ではありません。実際のモジュール名は <code>veryl_sample_delay</code> になります。</p>
</blockquote>
<h2 id="バージョン要求"><a class="header" href="#バージョン要求">バージョン要求</a></h2>
<p><code>[dependencies]</code> セクションの <code>version</code> フィールドはバージョン要求を示します。例えば、<code>version = "0.1.0"</code> は <code>0.1.0</code> と互換性のある最新バージョンを意味します。互換性は<a href="https://semver.org/">セマンティックバージョニング</a>で判定されます。バージョンは以下の3つの部分からなります。</p>
<ul>
<li><code>メジャー</code> バージョンはAPI非互換な変更</li>
<li><code>マイナー</code> バージョンは互換性のある機能追加</li>
<li><code>パッチ</code> バージョンは互換性のあるバグ修正</li>
</ul>
<p>もし <code>メジャー</code> バージョンが <code>0</code> なら、<code>マイナー</code> が非互換変更と解釈されます。</p>
<p>バージョン <code>0.1.0</code>、<code>0.1.1</code>、<code>0.2.0</code>があった場合、<code>0.1.1</code> が選択されます。これは以下のように決定されます。</p>
<ul>
<li><code>0.1.0</code> は <code>0.1.0</code> と互換性がある</li>
<li><code>0.1.1</code> は <code>0.1.0</code> と互換性がある</li>
<li><code>0.2.0</code> は <code>0.1.0</code> と互換性がない</li>
<li><code>0.1.1</code> は互換性のある最新バージョン</li>
</ul>
<p><code>version</code> フィールドは <code>=0.1.0</code> のような指定も可能です。詳細は Rust のバージョン要求についてのドキュメントを参照してください。<a href="https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#specifying-dependencies-from-cratesio">Specifying Dependencies</a>.</p>
<h2 id="相対パス依存関係"><a class="header" href="#相対パス依存関係">相対パス依存関係</a></h2>
<p>手元の環境で開発しているとき、ローカルファイルパスへの依存関係が使えると便利なことがあります。相対パス依存関係は以下のように指定することができます。</p>
<pre><code class="language-toml">[dependencies]
veryl_sample = {path = "../../veryl_sample"}
</code></pre>
<p>プロジェクトに相対パス依存関係がある場合、そのプロジェクトは <code>veryl publish</code> で公開することはできません。</p>
<h2 id="ローカルパスによる上書き"><a class="header" href="#ローカルパスによる上書き">ローカルパスによる上書き</a></h2>
<p>場合によってはローカルで変更されたバージョンの依存関係を使う必要があることもあります。そのような場合、以下のようにローカルパスによって依存関係を上書きすることができます。</p>
<pre><code class="language-toml">[dependencies]
veryl_sample = {github = "veryl-lang/veryl_sample", version = "0.1.0", path = "../veryl_sample"}
</code></pre>
<p>これは <code>../veryl_sample</code> が存在する場合はそれを使い、そうでない場合は Git から取得する、という意味です。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="プロジェクトを公開する"><a class="header" href="#プロジェクトを公開する">プロジェクトを公開する</a></h1>
<p>プロジェクトを公開するには <code>veryl publish</code> コマンドを使います。公開とはバージョン番号とgitのリビジョンを紐づけることです。</p>
<pre><code>$ veryl publish
[INFO ]   Publishing release (0.2.1 @ 297bc6b24c5ceca9e648c3ea5e01011c67d7efe7)
[INFO ]      Writing metadata ([path to project]/Veryl.pub)
</code></pre>
<p><code>veryl publish</code> は以下のように公開されたバージョンの情報を含んだ <code>Veryl.pub</code> というファイルを生成します。</p>
<pre><code class="language-toml">[[releases]]
version = "0.2.1"
revision = "297bc6b24c5ceca9e648c3ea5e01011c67d7efe7"
</code></pre>
<p><code>Veryl.pub</code> と生成した後、gitのadd、commit、pushを行えば公開手続きは完了です。gitブランチはデフォルトブランチでなければなりません。これは Veryl が <code>Veryl.pub</code> をデフォルトブランチから探すためです。</p>
<pre><code>$ git add Veryl.pub
$ git commit -m "Publish"
$ git push
</code></pre>
<p><code>Veryl.toml</code> の <code>[publish]</code> セクションに <code>publish_commit</code> を設定して自動コミットを有効にすれば、gitのaddとcommitが自動で実行されます。</p>
<pre><code>$ veryl publish
[INFO ]   Publishing release (0.2.1 @ 297bc6b24c5ceca9e648c3ea5e01011c67d7efe7)
[INFO ]      Writing metadata ([path to project]/Veryl.pub)
[INFO ]   Committing metadata ([path to project]/Veryl.pub)
</code></pre>
<h3 id="バージョンを上げる"><a class="header" href="#バージョンを上げる">バージョンを上げる</a></h3>
<p><code>--bump</code> オプションを使うと公開と同時にバージョンを上げることもできます。公開と同様に、<code>Veryl.toml</code> の<code>[publish]</code> セクションに <code>bump_commit</code> を設定すれば自動でcommitされます。</p>
<pre><code>$ veryl publish --bump patch
[INFO ]      Bumping version (0.2.1 -&gt; 0.2.2)
[INFO ]     Updating version field ([path to project]/Veryl.toml)
[INFO ]   Committing metadata ([path to project]/Veryl.toml)
[INFO ]   Publishing release (0.2.2 @ 159dee3b3f93d3a999d8bac4c6d26d51476b178a)
[INFO ]      Writing metadata ([path to project]/Veryl.pub)
[INFO ]   Committing metadata ([path to project]/Veryl.pub)
</code></pre>
<h3 id="設定-4"><a class="header" href="#設定-4">設定</a></h3>
<p>全設定の説明は<a href="06_development_environment/./01_project_configuration/05_publish.html">こちら</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ディレクトリ構成"><a class="header" href="#ディレクトリ構成">ディレクトリ構成</a></h1>
<p>Veryl は任意のディレクトリ構成をサポートしています。これは独立したプロジェクトと他のプロジェクトに組み込まれたプロジェクトでは最適なディレクトリ構成が異なるためです。</p>
<p>この節ではいくつかのディレクトリ構成パターンを示します。</p>
<h2 id="単一のソースディレクトリ"><a class="header" href="#単一のソースディレクトリ">単一のソースディレクトリ</a></h2>
<p>このパターンでは全てのソースコードは <code>src</code> ディレクトリに配置されます。<code>src</code> 以下のサブディレクトリの構成は自由です。</p>
<pre><code>$ tree
.
|-- src
|   |-- module_a.veryl
|   `-- module_b
|       |-- module_b.veryl
|       `-- module_c.veryl
`-- Veryl.toml

2 directories, 4 files
</code></pre>
<p>Veryl は全ての <code>*.veryl</code> ファイルを収集し、デフォルトではソースと同じディレクトリにコードを生成します。この挙動は以下の設定で明示することもできます。</p>
<pre><code class="language-toml">[build]
target = "source"
</code></pre>
<p><code>veryl build</code> を実行するとディレクトリ構成は以下のようになります。</p>
<pre><code>$ tree
.
|-- dependencies
|-- prj.f
|-- src
|   |-- module_a.sv
|   |-- module_a.veryl
|   `-- module_b
|       |-- module_b.sv
|       |-- module_b.veryl
|       |-- module_c.sv
|       `-- module_c.veryl
`-- Veryl.toml

3 directories, 8 files
</code></pre>
<h2 id="単一のソースとターゲットディレクトリ"><a class="header" href="#単一のソースとターゲットディレクトリ">単一のソースとターゲットディレクトリ</a></h2>
<p>生成されたコードを1つのディレクトリに入れたい場合、<code>Veryl.toml</code> の <code>[build]</code> セクションで <code>target</code> を以下のように設定します。</p>
<pre><code class="language-toml">[build]
target = {type = "directory", path = "target"}
</code></pre>
<p>ディレクトリ構成は以下のようになります。</p>
<pre><code>$ tree
.
|-- dependencies
|-- prj.f
|-- src
|   |-- module_a.veryl
|   `-- module_b
|       |-- module_b.veryl
|       `-- module_c.veryl
|-- target
|   |-- module_a.sv
|   |-- module_b.sv
|   `-- module_c.sv
`-- Veryl.toml

4 directories, 8 files
</code></pre>
<h2 id="マルチソースディレクトリ"><a class="header" href="#マルチソースディレクトリ">マルチソースディレクトリ</a></h2>
<p>既存の SystemVerilog プロジェクトに Veryl のプロジェクトを組み込む場合、以下のような構成にすることもできます。</p>
<pre><code>$ tree
.
|-- dependencies
|-- module_a
|   |-- module_a.sv
|   `-- module_a.veryl
|-- module_b
|   |-- module_b.sv
|   |-- module_b.veryl
|   |-- module_c.sv
|   `-- module_c.veryl
|-- prj.f
|-- sv_module_x
|   `-- sv_module_x.sv
|-- sv_module_y
|   `-- sv_module_y.sv
`-- Veryl.toml

5 directories, 10 files
</code></pre>
<p>生成された <code>prj.f</code> は生成されたソースコードを全てリストアップしているので、既存の SystemVerilog ファイルリストと一緒に使うことができます。</p>
<h2 id="gitignore-について"><a class="header" href="#gitignore-について"><code>.gitignore</code> について</a></h2>
<p>Verylは以下の <code>.gitignore</code> をデフォルト値として提供します。<code>.build</code> ディレクトリはVerylコンパイラがビルド情報を記録するために使用します。</p>
<pre><code>.build/
</code></pre>
<p>それ以外のパターンはプロジェクトに合わせて追加できます。<code>.gitignore</code> の候補としては以下が考えられます。</p>
<ul>
<li><code>dependencies/</code></li>
<li><code>target/</code></li>
<li><code>*.sv</code></li>
<li><code>*.f</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="フォーマッタ"><a class="header" href="#フォーマッタ">フォーマッタ</a></h1>
<p><code>veryl fmt</code> コマンドでソースコードをフォーマットできます。あるいは言語サーバの <code>textDocument/formatting</code> 要求によるフォーマットにも対応しています。</p>
<p>全設定の説明は<a href="06_development_environment/./01_project_configuration/02_format.html">こちら</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="リンタ"><a class="header" href="#リンタ">リンタ</a></h1>
<p><code>veryl check</code> あるいは <code>veryl build</code> でリントチェックができます。あるいは言語サーバはリアルタイムでのチェックを行います。</p>
<p>全設定の説明は<a href="06_development_environment/./01_project_configuration/03_lint.html">こちら</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="シミュレータ"><a class="header" href="#シミュレータ">シミュレータ</a></h1>
<p>RTLシミュレータによるテストは <code>veryl test</code> で実行することができます。サポートされているシミュレータは以下の通りです。</p>
<ul>
<li><a href="https://www.veripool.org/verilator/">Verilator</a></li>
<li><a href="https://www.synopsys.com/verification/simulation/vcs.html">Synopsys VCS</a></li>
<li><a href="https://altair.com/dsim">Altair DSim</a></li>
<li><a href="https://www.xilinx.com/products/design-tools/vivado/verification.html">AMD Vivado Simulator</a></li>
</ul>
<p>Verilatorはデフォルトのシミュレータです。<code>Veryl.toml</code>やコマンドラインオプションでシミュレータが指定されていない場合に使用されます。</p>
<p>全設定の説明は<a href="06_development_environment/./01_project_configuration/04_test.html">こちら</a>。</p>
<h2 id="cocotb"><a class="header" href="#cocotb">cocotb</a></h2>
<p><code>cocotb</code> テストを実行するには <code>cocotb</code> がインストールされた <code>python3</code> の環境が必要です。サポートされている <code>cocotb</code> のバージョンは 1.9.x あるいは 2.0.x です。</p>
<p>例えば以下のコマンドでインストールすることができます。</p>
<pre><code class="language-console">$ pip3 install cocotb==2.0.0
</code></pre>
<p>シミュレータバックエンドとしては Verilator のみサポートされています。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="言語サーバ"><a class="header" href="#言語サーバ">言語サーバ</a></h1>
<p><code>veryl-ls</code> は言語サーバのバイナリです。使用するにはエディタの設定やプラグインが必要です。</p>
<p>設定可能な項目は以下の通りです。これは各エディタの設定から指定できます。</p>
<div class="table-wrapper"><table><thead><tr><th>設定</th><th>設定値</th><th>デフォルト</th><th>説明</th></tr></thead><tbody>
<tr><td>useOperatorCompletion</td><td>ブーリアン</td><td>false</td><td>演算子（例 ‘&gt;:’, ‘&gt;&gt;’）の補完を有効にする</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="互換性"><a class="header" href="#互換性">互換性</a></h1>
<p>いくつかのツールはサポートしていない SystemVerilog 構文があります。これをサポートするために、 <code>Veryl.toml</code> の設定でコード生成をカスタマイズすることができます。</p>
<h2 id="vivado"><a class="header" href="#vivado">Vivado</a></h2>
<h3 id="文字列パラメータ"><a class="header" href="#文字列パラメータ">文字列パラメータ</a></h3>
<p>Vivadoは <code>string</code> 型の <code>parameter</code> をサポートしていません。</p>
<pre><code class="language-verilog">parameter string a = "A";
</code></pre>
<p>その場合は <code>implicit_parameter_types</code> を設定してください。</p>
<pre><code class="language-toml">[build]
implicit_parameter_types = ["string"]
</code></pre>
<p>設定すると生成コードは以下のようになります。</p>
<pre><code class="language-verilog">parameter a = "A";
</code></pre>
<h2 id="quartus"><a class="header" href="#quartus">Quartus</a></h2>
<h3 id="inside-演算子"><a class="header" href="#inside-演算子"><code>inside</code> 演算子</a></h3>
<p>Quartus は <code>inside</code> 演算子をサポートしていません。その場合は <code>expand_inside_operation</code> を設定してください。</p>
<pre><code class="language-toml">[build]
expand_inside_operation = true
</code></pre>
<p>設定すると、 <code>inside</code> 演算子を使った演算は <code>==?</code> 演算子を使った論理に展開されます。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ドキュメンテーション"><a class="header" href="#ドキュメンテーション">ドキュメンテーション</a></h1>
<p>プロジェクトのドキュメントは <code>veryl doc</code> コマンドで生成することができます。全てのパブリックなモジュールとインターフェース、パッケージがリストアップされます。（参照 <a href="06_development_environment/../05_language_reference/11_visibility.html">可視性</a>）</p>
<p>詳細な説明を書きたい場合はドキュメンテーションコメントを追加することもできます。ドキュメンテーションコメントでは<a href="https://www.markdownguide.org">マークダウン</a>記法を使えます。</p>
<p>以下のフォーマットもサポートされています。</p>
<ul>
<li><a href="https://wavedrom.com">WaveDrom</a>による波形記述</li>
<li><a href="https://mermaid.js.org">Mermaid</a>によるダイアグラム記述</li>
</ul>
<p>それぞれの構文は <code>wavedrom</code> と <code>mermaid</code> コードブロック内で使用できます。</p>
<p>詳細な構文は以下を参照してください。</p>
<ul>
<li><a href="https://mermaid.js.org/ecosystem/tutorials.html">Tutorials | Mermaid</a></li>
<li><a href="https://wavedrom.com/tutorial.html">Hitchhiker’s Guide to the WaveDrom</a></li>
</ul>
<pre><code class="language-veryl playground">/// ModuleAの詳細説明
///
/// * リスト要素0
/// * リスト要素1
///
/// ```wavedrom
/// {signal: [
///   {name: 'clk', wave: 'p.....|...'},
///   {name: 'dat', wave: 'x.345x|=.x', data: ['head', 'body', 'tail', 'data']},
///   {name: 'req', wave: '0.1..0|1.0'},
///   {},
///   {name: 'ack', wave: '1.....|01.'}
///
/// ]}
/// ```
pub module ModuleA #(
    /// データ幅
    param ParamA: u32 = 1,
    local ParamB: u32 = 1,
) (
    i_clk : input  clock        , /// クロック
    i_rst : input  reset        , /// リセット
    i_data: input  logic&lt;ParamA&gt;, /// データ入力
    o_data: output logic&lt;ParamA&gt;, /// データ出力
) {
    assign o_data = 0;
}
</code></pre>
<p>設定可能な項目は以下の通りです。これは <code>Veryl.toml</code> の <code>[doc]</code> セクションで指定できます。</p>
<pre><code class="language-toml">[doc]
path = "document"
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>設定</th><th>設定値</th><th>デフォルト</th><th>説明</th></tr></thead><tbody>
<tr><td>path</td><td>文字列</td><td>“doc”</td><td>出力ディレクトリへのパス</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="github-action"><a class="header" href="#github-action">GitHub Action</a></h1>
<p>ビルド済みのVerylバイナリをダウンロードするための公式GitHub actionが提供されています。</p>
<p><a href="https://github.com/marketplace/actions/setup-veryl">https://github.com/marketplace/actions/setup-veryl</a></p>
<p>GitHub actionスクリプトの例は以下の通りです。</p>
<ul>
<li>フォーマットとビルドチェック</li>
</ul>
<pre><code class="language-yaml">name: Check
on: [push, pull_request]
jobs:
  check:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    - uses: veryl-lang/setup-veryl@v1
    - run: veryl fmt --check
    - run: veryl check
</code></pre>
<ul>
<li>GitHub Pagesからドキュメントを公開する</li>
</ul>
<pre><code class="language-yaml">name: Deploy
on: [push]
jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    - uses: veryl-lang/setup-veryl@v1
    - run: veryl doc
    - uses: peaceiris/actions-gh-pages@v3
      with:
        github_token: ${{ secrets.GITHUB_TOKEN }}
        publish_dir: doc
</code></pre>
<ul>
<li><a href="https://www.veripool.org/verilator/">Verilator</a> によるテスト</li>
</ul>
<p>このために GitHub action <a href="https://github.com/marketplace/actions/setup-verilator">veryl-lang/setup-verilator</a> を公開しています。</p>
<pre><code class="language-yaml">name: Test
on: [push, pull_request]
jobs:
  test:
    runs-on: ubuntu-22.04
    steps:
    - uses: actions/checkout@v4
    - uses: veryl-lang/setup-veryl@v1
    - uses: veryl-lang/setup-verilator@v1
    - run: veryl test --sim verilator
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ソースマップ"><a class="header" href="#ソースマップ">ソースマップ</a></h1>
<p>ソースマップはSystemVerilogからVerylへ位置情報を追跡するために使用されるファイルです。このファイルによって、SystemVerilogのファイルパス・行・列をVeryl上の位置に変換することができます。</p>
<p>デフォルトではVerylは生成されたSystemVerilogと同じディレクトリに拡張子 <code>.sv.map</code> のソースマップを生成します。ソースマップの生成は <code>Veryl.toml</code> の <a href="06_development_environment/./01_project_configuration/01_build.html#sourcemap-target"><code>sourcemap_target</code> フィールド</a>で制御することができます。</p>
<p>ソースマップの形式は <a href="https://sourcemaps.info/spec.html">Source Map Revision 3</a> に従います。生成されたコードとマップのリンク方法はJavaScriptのものとほとんど同じですが、相対パスのみが使われます。</p>
<pre><code class="language-verilog">//# sourceMappingURL=&lt;relative path&gt;
</code></pre>
<p>従って、上記のコメントがSystemVerilogファイルの末尾にあればソースマップが利用可能です。</p>
<h2 id="sourcemap-resolver"><a class="header" href="#sourcemap-resolver">sourcemap-resolver</a></h2>
<p><code>sourcemap-resolver</code> は Veryl コンパイラに同梱されており、任意のテキストファイルに以下のような注釈を付けることができます。</p>
<pre><code>ERROR: [VRFC 10-4982] syntax error near 'endmodule' [/path/test.sv:23]
                                                     ^-- /path/test.veryl:18:18
</code></pre>
<p>最初の行が元のテキストで、2行目が <code>sourcemap-resolver</code> により追加された行です。使用例は以下の通りです。</p>
<pre><code>$ sourcemap-resolver test.log      # annotate the existing log
$ [command] | sourcemap-resolver   # on-the-fly annotation by pipe
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="verylup"><a class="header" href="#verylup">verylup</a></h1>
<p><a href="https://github.com/veryl-lang/verylup">verylup</a> はVerylの公式ツールチェーンインストーラです。ツールチェーンの更新や切り替えを簡単に行うことができます。</p>
<h2 id="ツールチェーンの更新"><a class="header" href="#ツールチェーンの更新">ツールチェーンの更新</a></h2>
<p>以下のコマンドはVerylツールチェーンとverylupを最新版に更新します。</p>
<pre><code>verylup update
</code></pre>
<h2 id="特定のツールチェーンをインストール"><a class="header" href="#特定のツールチェーンをインストール">特定のツールチェーンをインストール</a></h2>
<p>もし特定のバージョンのVerylを使用したい場合は、<code>verylup install</code> を使うことができます。</p>
<pre><code>verylup install 0.12.0
</code></pre>
<p>インストール後、<code>veryl</code> コマンドで <code>+</code> によるバージョン指定が可能になります。</p>
<pre><code>veryl +0.12.0 build
</code></pre>
<p><code>+0.12</code> のように指定すると、<code>0.12.x</code> のうち最新バージョンが選択されます。</p>
<h2 id="ディレクトリ毎のツールチェーンオーバーライド"><a class="header" href="#ディレクトリ毎のツールチェーンオーバーライド">ディレクトリ毎のツールチェーンオーバーライド</a></h2>
<p>もし特定にディレクトリで特定のバージョンのVerylを使用したい場合は、<code>verylup override</code> を使うことができます。</p>
<pre><code>verylup override set 0.12.0
</code></pre>
<p><code>verylup override</code> はVerylプロジェクト内の任意のディレクトリで実行できます。このコマンドを実行すると、そのプロジェクトのデフォルトのツールチェーンは <code>0.12.0</code> になります。</p>
<h2 id="offline-installation"><a class="header" href="#offline-installation">オフラインインストール</a></h2>
<p>インターネットアクセスのない環境にインストールしたい場合は、オフラインインストールが利用できます。オフラインインストールの手順は以下の通りです。</p>
<ul>
<li>最新のツールチェーンパッケージを<a href="https://github.com/veryl-lang/veryl/releases/latest">Veryl リリースページ</a>からダウンロードする</li>
<li>以下のように<code>veryl setup</code> を <code>--pkg</code> 指定付きで実行する</li>
</ul>
<pre><code>verylup setup --offline --pkg veryl-x86_64-linux.zip
</code></pre>
<p>ツールチェーンの更新やインストールもセットアップと同様に <code>--pkg</code> 指定が必要です。</p>
<pre><code>verylup update --pkg veryl-x86_64-linux.zip
verylup install 0.12.0 --pkg veryl-x86_64-linux.zip
</code></pre>
<h2 id="プロキシ"><a class="header" href="#プロキシ">プロキシ</a></h2>
<p>Verylupはプロキシ設定として以下の環境変数を参照します。</p>
<ul>
<li><code>HTTPS_PROXY</code></li>
<li><code>https_proxy</code></li>
<li><code>ALL_PROXY</code></li>
<li><code>all_proxy</code></li>
</ul>
<p>プロキシのプロトコルとしては <code>http</code> と <code>socks5</code> がサポートされています。</p>
<h3 id="プロキシ設定"><a class="header" href="#プロキシ設定">プロキシ設定</a></h3>
<p>環境変数の代わりにverylupだけのプロキシ設定を指定することができます。</p>
<pre><code>verylup config set proxy socks5://127.0.0.1:1086
</code></pre>
<h2 id="ナイトリーチャンネル"><a class="header" href="#ナイトリーチャンネル">ナイトリーチャンネル</a></h2>
<p>最新の機能を簡単に試すために、ナイトリーチャンネルが利用できます。ナイトリーチャンネルはマスターブランチから毎日ビルドされます。</p>
<pre><code>verylup install nightly
</code></pre>
<p>デフォルトではナイトリーチャンネルはインストールしても有効になりません。以下の方法で有効にすることができます。</p>
<pre><code>// +nightly を使う
veryl +nightly build

// デフォルトをナイトリーにする
verylup default nightly

// 特定のプロジェクトをナイトリーで上書きする
verylup override set nightly
</code></pre>
<h2 id="veryl開発者向け"><a class="header" href="#veryl開発者向け">Veryl開発者向け</a></h2>
<p>Veryl の開発者向けに、特別なツールチェーン <code>local</code> が用意されています。<code>verylup install local</code> をローカルのVerylリポジトリ上で実行すると、ビルドしたツールチェーンを <code>local</code> ツールチェーンとしてインストールします。<code>local</code> ツールチェーンが存在するときはデフォルトのツールチェーンになります。</p>
<pre><code>// ローカルのVerylリポジトリでビルドしたツールチェーンをインストール
verylup install local

// ビルドしたツールチェーンを使う
veryl build

// 最新のツールチェーンを使う
veryl +latest build
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="新バージョンへの移行"><a class="header" href="#新バージョンへの移行">新バージョンへの移行</a></h1>
<p>Verylの新しいバージョンが破壊的な変更を伴うことがあります。<code>veryl migrate</code> は既存のプロジェクトを新バージョンに自動的に移行します。<code>--check</code> オプションによりどのような変更が適用されるか事前に確認することもできます。</p>
<pre><code class="language-console">$ veryl migrate --check
$ veryl migrate
</code></pre>
<p><code>veryl migrate</code> は単一のメジャーバージョン（1.0まではマイナーバージョン）しか移行しません。複数のバージョンを移行するには以下のようにしてください。</p>
<pre><code class="language-console">$ veryl +0.15.0 migrate  # from v0.14.0 to v0.15.0
$ veryl +0.16.0 migrate  # from v0.15.0 to v0.16.0
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="docker-イメージ"><a class="header" href="#docker-イメージ">Docker イメージ</a></h1>
<p>公式のDockerイメージはDocker Hubを通して提供されています。</p>
<p><a href="https://hub.docker.com/r/veryllang/veryl">https://hub.docker.com/r/veryllang/veryl</a></p>
<p>イメージはカスタムイメージのベースや、GitLab CI/CDのために使うことができます。以下に使用例をいくつか示します。</p>
<h2 id="docker-コマンド"><a class="header" href="#docker-コマンド"><code>docker</code> コマンド</a></h2>
<p>イメージを <code>veryllang/veryl</code> からプルできます。</p>
<pre><code class="language-console">$ docker pull veryllang/veryl
</code></pre>
<h2 id="dockerfile"><a class="header" href="#dockerfile"><code>Dockerfile</code></a></h2>
<p>Dockerイメージのベースとして使用する場合は、以下の <code>FROM</code> ディレクティブを使用できます。</p>
<pre><code class="language-Dockerfile">FROM veryllang/veryl:latest
</code></pre>
<h2 id="gitlab-cicd"><a class="header" href="#gitlab-cicd">GitLab CI/CD</a></h2>
<p>GitLab CI/CD のための <code>.gitlab-ci.yml</code> の例は以下になります。</p>
<pre><code class="language-yaml">image: "veryllang/veryl"

build:
  stage: build
  script:
    - veryl build

fmt:
  stage: build
  script:
    - veryl fmt --check
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="補遺"><a class="header" href="#補遺">補遺</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="構文"><a class="header" href="#構文">構文</a></h1>
<p>Veryl のパーサはパーサジェネレータ <a href="https://github.com/jsinger67/parol">parol</a>を使っています。以下の parol の構文定義が正式な構文です。</p>
<pre><code>
%start Veryl
%title "Veryl grammar"
%comment "Empty grammar generated by `parol`"
%user_type VerylToken = crate::veryl_token::VerylToken
%user_type Token = crate::veryl_token::Token

%on HashLBracketTerm %push Attr
%on ColonColonLAngleTerm %push Generic
%on EscapedRBraceTerm %pop
%on EmbedTerm %enter EmbedHeader

%scanner EmbedHeader {
    %on TripleLBraceTerm %enter EmbedBody
}

%scanner EmbedBody {
    %auto_newline_off
    %auto_ws_off

    %on LBraceTerm %push EmbedBodyInner
    %on EscapedLBraceTerm %push INITIAL
    %on TripleRBraceTerm %enter INITIAL
}

%scanner EmbedBodyInner {
    %auto_newline_off
    %auto_ws_off

    %on LBraceTerm %push EmbedBodyInner
    %on EscapedLBraceTerm %push INITIAL
    %on RBraceTerm %pop
}

%scanner Generic {
    %on ColonColonLAngleTerm %push Generic
    %on RAngleTerm %pop
}

%scanner Attr {
    %on RBracketTerm %pop
}

%%

// ----------------------------------------------------------------------------
// Terminal
// ----------------------------------------------------------------------------

// Longest match should be first

CommentsTerm          : &lt;INITIAL, Generic, EmbedHeader,                            Attr&gt;"(?:(?:(?://.*(?:\r\n|\r|\n))|(?:(?ms)/\*/?([^/]|[^*]/)*\*/))\s*)+"                   : Token;
StringLiteralTerm     : &lt;INITIAL         ,                                         Attr&gt;"\u{0022}(?:\\[\u{0022}\\/bfnrt]|u[0-9a-fA-F]{4}|[^\u{0022}\\\u0000-\u001F])*\u{0022}": Token;
ExponentTerm          : &lt;INITIAL, Generic                                              &gt;/[0-9]+(?:_[0-9]+)*\.[0-9]+(?:_[0-9]+)*[eE][+-]?[0-9]+(?:_[0-9]+)*/                   : Token;
FixedPointTerm        : &lt;INITIAL, Generic                                              &gt;/[0-9]+(?:_[0-9]+)*\.[0-9]+(?:_[0-9]+)*/                                              : Token;
BasedTerm             : &lt;INITIAL, Generic                                              &gt;/(?:[0-9]+(?:_[0-9]+)*)?'s?[bodh][0-9a-fA-FxzXZ]+(?:_[0-9a-fA-FxzXZ]+)*/              : Token;
AllBitTerm            : &lt;INITIAL, Generic                                              &gt;/(?:[0-9]+(?:_[0-9]+)*)?'[01xzXZ]/                                                    : Token;
BaseLessTerm          : &lt;INITIAL, Generic                                              &gt;/[0-9]+(?:_[0-9]+)*/                                                                  : Token;
MinusColonTerm        : &lt;INITIAL                                                       &gt;'-:'                                                                                  : Token;
MinusGTTerm           : &lt;INITIAL                                                       &gt;'-&gt;'                                                                                  : Token;
LTMinusTerm           : &lt;INITIAL                                                       &gt;'&lt;-'                                                                                  : Token;
PlusColonTerm         : &lt;INITIAL                                                       &gt;'+:'                                                                                  : Token;
AssignmentOperatorTerm: &lt;INITIAL                                                       &gt;"\+=|-=|\*=|/=|%=|&amp;=|\|=|\^=|&lt;&lt;=|&gt;&gt;=|&lt;&lt;&lt;=|&gt;&gt;&gt;="                                       : Token;
DiamondOperatorTerm   : &lt;INITIAL                                                       &gt;'&lt;&gt;'                                                                                  : Token;
Operator12Term        : &lt;INITIAL                                                       &gt;"\*\*"                                                                                : Token;
Operator11Term        : &lt;INITIAL                                                       &gt;"/|%"                                                                                 : Token;
Operator10Term        : &lt;INITIAL                                                       &gt;"\+|-"                                                                                : Token;
Operator09Term        : &lt;INITIAL                                                       &gt;"&lt;&lt;&lt;|&gt;&gt;&gt;|&lt;&lt;|&gt;&gt;"                                                                       : Token;
Operator08Term        : &lt;INITIAL                                                       &gt;"&lt;=|&gt;=|&lt;:|&gt;:"                                                                         : Token;
Operator07Term        : &lt;INITIAL                                                       &gt;"==\?|!=\?|==|!="                                                                     : Token;
Operator03Term        : &lt;INITIAL                                                       &gt;"&amp;&amp;"                                                                                  : Token;
Operator02Term        : &lt;INITIAL                                                       &gt;"\|\|"                                                                                : Token;
Operator06Term        : &lt;INITIAL                                                       &gt;"&amp;"                                                                                   : Token;
Operator05Term        : &lt;INITIAL                                                       &gt;"\^|~\^"                                                                              : Token;
Operator04Term        : &lt;INITIAL                                                       &gt;"\|"                                                                                  : Token;
UnaryOperatorTerm     : &lt;INITIAL                                                       &gt;"~&amp;|~\||!|~"                                                                          : Token;
ColonColonLAngleTerm  : &lt;INITIAL, Generic                                              &gt;'::&lt;'                                                                                 : Token;
ColonColonTerm        : &lt;INITIAL, Generic                                              &gt;'::'                                                                                  : Token;
ColonTerm             : &lt;INITIAL, Generic                                              &gt;':'                                                                                   : Token;
CommaTerm             : &lt;INITIAL, Generic,                                         Attr&gt;','                                                                                   : Token;
DotDotEquTerm         : &lt;INITIAL                                                       &gt;'..='                                                                                 : Token;
DotDotTerm            : &lt;INITIAL                                                       &gt;'..'                                                                                  : Token;
DotTerm               : &lt;INITIAL, Generic                                              &gt;'.'                                                                                   : Token;
EquTerm               : &lt;INITIAL, Generic                                              &gt;'='                                                                                   : Token;
HashLBracketTerm      : &lt;INITIAL                                                       &gt;'#['                                                                                  : Token;
HashTerm              : &lt;INITIAL                                                       &gt;'#'                                                                                   : Token;
LAngleTerm            : &lt;INITIAL                                                       &gt;'&lt;'                                                                                   : Token;
QuestionTerm          : &lt;INITIAL                                                       &gt;'?'                                                                                   : Token;
QuoteLBraceTerm       : &lt;INITIAL                                                       &gt;"'\{"                                                                                 : Token;
QuoteTerm             : &lt;INITIAL                                                       &gt;"'"                                                                                   : Token;
EscapedLBraceTerm     : &lt;                               EmbedBody, EmbedBodyInner      &gt;'\{'                                                                                  : Token;
TripleLBraceTerm      : &lt;                  EmbedHeader                                 &gt;'{{{'                                                                                 : Token;
LBraceTerm            : &lt;INITIAL         ,              EmbedBody, EmbedBodyInner, Attr&gt;'{'                                                                                   : Token;
LBracketTerm          : &lt;INITIAL,                                                  Attr&gt;'['                                                                                   : Token;
LParenTerm            : &lt;INITIAL         , EmbedHeader,                            Attr&gt;'('                                                                                   : Token;
RAngleTerm            : &lt;INITIAL, Generic                                              &gt;'&gt;'                                                                                   : Token;
EscapedRBraceTerm     : &lt;INITIAL                                                       &gt;'\}'                                                                                  : Token;
TripleRBraceTerm      : &lt;                               EmbedBody                      &gt;'}}}'                                                                                 : Token;
RBraceTerm            : &lt;INITIAL,                                  EmbedBodyInner, Attr&gt;'}'                                                                                   : Token;
RBracketTerm          : &lt;INITIAL,                                                  Attr&gt;']'                                                                                   : Token;
RParenTerm            : &lt;INITIAL,          EmbedHeader,                            Attr&gt;')'                                                                                   : Token;
SemicolonTerm         : &lt;INITIAL                                                       &gt;';'                                                                                   : Token;
StarTerm              : &lt;INITIAL                                                       &gt;'*'                                                                                   : Token;

// Keywords are reflected to syntax highlight definitions through highlightgen tool.
// Please refer support/highlightgen/README.md if you want to add a keyword.

AliasTerm             : &lt;INITIAL, Generic                                             &gt;'alias'                                                                               : Token; // Keyword: Statement
AlwaysCombTerm        : &lt;INITIAL, Generic                                             &gt;'always_comb'                                                                         : Token; // Keyword: Statement
AlwaysFfTerm          : &lt;INITIAL, Generic                                             &gt;'always_ff'                                                                           : Token; // Keyword: Statement
AssignTerm            : &lt;INITIAL, Generic                                             &gt;'assign'                                                                              : Token; // Keyword: Statement
AsTerm                : &lt;INITIAL, Generic                                             &gt;'as'                                                                                  : Token; // Keyword: Statement
BindTerm              : &lt;INITIAL, Generic                                             &gt;'bind'                                                                                : Token; // Keyword: Statement
BitTerm               : &lt;INITIAL, Generic                                             &gt;'bit'                                                                                 : Token; // Keyword: Type
BlockTerm             : &lt;INITIAL, Generic                                             &gt;'block'                                                                               : Token; // Keyword: Statement
BBoolTerm             : &lt;INITIAL, Generic                                             &gt;'bbool'                                                                               : Token; // Keyword: Type
LBoolTerm             : &lt;INITIAL, Generic                                             &gt;'lbool'                                                                               : Token; // Keyword: Type
CaseTerm              : &lt;INITIAL, Generic                                             &gt;'case'                                                                                : Token; // Keyword: Conditional
ClockTerm             : &lt;INITIAL, Generic                                             &gt;'clock'                                                                               : Token; // Keyword: Type
ClockPosedgeTerm      : &lt;INITIAL, Generic                                             &gt;'clock_posedge'                                                                       : Token; // Keyword: Type
ClockNegedgeTerm      : &lt;INITIAL, Generic                                             &gt;'clock_negedge'                                                                       : Token; // Keyword: Type
ConnectTerm           : &lt;INITIAL, Generic                                             &gt;'connect'                                                                             : Token; // Keyword: Statement
ConstTerm             : &lt;INITIAL, Generic                                             &gt;'const'                                                                               : Token; // Keyword: Statement
ConverseTerm          : &lt;INITIAL, Generic                                             &gt;'converse'                                                                            : Token; // Keyword: Direction
DefaultTerm           : &lt;INITIAL, Generic                                             &gt;'default'                                                                             : Token; // Keyword: Conditional
ElseTerm              : &lt;INITIAL, Generic                                             &gt;'else'                                                                                : Token; // Keyword: Conditional
EmbedTerm             : &lt;INITIAL, Generic                                             &gt;'embed'                                                                               : Token; // Keyword: Structure
EnumTerm              : &lt;INITIAL, Generic                                             &gt;'enum'                                                                                : Token; // Keyword: Structure
F32Term               : &lt;INITIAL, Generic                                             &gt;'f32'                                                                                 : Token; // Keyword: Type
F64Term               : &lt;INITIAL, Generic                                             &gt;'f64'                                                                                 : Token; // Keyword: Type
FalseTerm             : &lt;INITIAL, Generic                                             &gt;'false'                                                                               : Token; // Keyword: Literal
FinalTerm             : &lt;INITIAL, Generic                                             &gt;'final'                                                                               : Token; // Keyword: Statement
ForTerm               : &lt;INITIAL, Generic                                             &gt;'for'                                                                                 : Token; // Keyword: Repeat
FunctionTerm          : &lt;INITIAL, Generic                                             &gt;'function'                                                                            : Token; // Keyword: Structure
I8Term                : &lt;INITIAL, Generic                                             &gt;'i8'                                                                                  : Token; // Keyword: Type
I16Term               : &lt;INITIAL, Generic                                             &gt;'i16'                                                                                 : Token; // Keyword: Type
I32Term               : &lt;INITIAL, Generic                                             &gt;'i32'                                                                                 : Token; // Keyword: Type
I64Term               : &lt;INITIAL, Generic                                             &gt;'i64'                                                                                 : Token; // Keyword: Type
IfResetTerm           : &lt;INITIAL, Generic                                             &gt;'if_reset'                                                                            : Token; // Keyword: Conditional
IfTerm                : &lt;INITIAL, Generic                                             &gt;'if'                                                                                  : Token; // Keyword: Conditional
ImportTerm            : &lt;INITIAL, Generic                                             &gt;'import'                                                                              : Token; // Keyword: Statement
IncludeTerm           : &lt;INITIAL, Generic                                             &gt;'include'                                                                             : Token; // Keyword: Structure
InitialTerm           : &lt;INITIAL, Generic                                             &gt;'initial'                                                                             : Token; // Keyword: Statement
InoutTerm             : &lt;INITIAL, Generic                                             &gt;'inout'                                                                               : Token; // Keyword: Direction
InputTerm             : &lt;INITIAL, Generic                                             &gt;'input'                                                                               : Token; // Keyword: Direction
InsideTerm            : &lt;INITIAL, Generic                                             &gt;'inside'                                                                              : Token; // Keyword: Conditional
InstTerm              : &lt;INITIAL, Generic                                             &gt;'inst'                                                                                : Token; // Keyword: Statement
InterfaceTerm         : &lt;INITIAL, Generic                                             &gt;'interface'                                                                           : Token; // Keyword: Structure
InTerm                : &lt;INITIAL, Generic                                             &gt;'in'                                                                                  : Token; // Keyword: Repeat
LetTerm               : &lt;INITIAL, Generic                                             &gt;'let'                                                                                 : Token; // Keyword: Statement
LogicTerm             : &lt;INITIAL, Generic                                             &gt;'logic'                                                                               : Token; // Keyword: Type
LsbTerm               : &lt;INITIAL, Generic                                             &gt;'lsb'                                                                                 : Token; // Keyword: Literal
ModportTerm           : &lt;INITIAL, Generic                                             &gt;'modport'                                                                             : Token; // Keyword: Structure
ModuleTerm            : &lt;INITIAL, Generic                                             &gt;'module'                                                                              : Token; // Keyword: Structure
MsbTerm               : &lt;INITIAL, Generic                                             &gt;'msb'                                                                                 : Token; // Keyword: Literal
OutputTerm            : &lt;INITIAL, Generic                                             &gt;'output'                                                                              : Token; // Keyword: Direction
OutsideTerm           : &lt;INITIAL, Generic                                             &gt;'outside'                                                                             : Token; // Keyword: Conditional
PackageTerm           : &lt;INITIAL, Generic                                             &gt;'package'                                                                             : Token; // Keyword: Structure
ParamTerm             : &lt;INITIAL, Generic                                             &gt;'param'                                                                               : Token; // Keyword: Statement
ProtoTerm             : &lt;INITIAL, Generic                                             &gt;'proto'                                                                               : Token; // Keyword: Structure
PubTerm               : &lt;INITIAL, Generic                                             &gt;'pub'                                                                                 : Token; // Keyword: Structure
RepeatTerm            : &lt;INITIAL, Generic                                             &gt;'repeat'                                                                              : Token; // Keyword: Repeat
ResetTerm             : &lt;INITIAL, Generic                                             &gt;'reset'                                                                               : Token; // Keyword: Type
ResetAsyncHighTerm    : &lt;INITIAL, Generic                                             &gt;'reset_async_high'                                                                    : Token; // Keyword: Type
ResetAsyncLowTerm     : &lt;INITIAL, Generic                                             &gt;'reset_async_low'                                                                     : Token; // Keyword: Type
ResetSyncHighTerm     : &lt;INITIAL, Generic                                             &gt;'reset_sync_high'                                                                     : Token; // Keyword: Type
ResetSyncLowTerm      : &lt;INITIAL, Generic                                             &gt;'reset_sync_low'                                                                      : Token; // Keyword: Type
ReturnTerm            : &lt;INITIAL, Generic                                             &gt;'return'                                                                              : Token; // Keyword: Statement
RevTerm               : &lt;INITIAL, Generic                                             &gt;'rev'                                                                                 : Token; // Keyword: Repeat
BreakTerm             : &lt;INITIAL, Generic                                             &gt;'break'                                                                               : Token; // Keyword: Statement
SameTerm              : &lt;INITIAL, Generic                                             &gt;'same'                                                                                : Token; // Keyword: Direction
SignedTerm            : &lt;INITIAL, Generic                                             &gt;'signed'                                                                              : Token; // Keyword: Type
StepTerm              : &lt;INITIAL, Generic                                             &gt;'step'                                                                                : Token; // Keyword: Repeat
StringTerm            : &lt;INITIAL, Generic                                             &gt;'string'                                                                              : Token; // Keyword: Type
StructTerm            : &lt;INITIAL, Generic                                             &gt;'struct'                                                                              : Token; // Keyword: Structure
SwitchTerm            : &lt;INITIAL, Generic                                             &gt;'switch'                                                                              : Token; // Keyword: Conditional
TriTerm               : &lt;INITIAL, Generic                                             &gt;'tri'                                                                                 : Token; // Keyword: Type
TrueTerm              : &lt;INITIAL, Generic                                             &gt;'true'                                                                                : Token; // Keyword: Literal
TypeTerm              : &lt;INITIAL, Generic                                             &gt;'type'                                                                                : Token; // Keyword: Statement
U8Term                : &lt;INITIAL, Generic                                             &gt;'u8'                                                                                  : Token; // Keyword: Type
U16Term               : &lt;INITIAL, Generic                                             &gt;'u16'                                                                                 : Token; // Keyword: Type
U32Term               : &lt;INITIAL, Generic                                             &gt;'u32'                                                                                 : Token; // Keyword: Type
U64Term               : &lt;INITIAL, Generic                                             &gt;'u64'                                                                                 : Token; // Keyword: Type
UnionTerm             : &lt;INITIAL, Generic                                             &gt;'union'                                                                               : Token; // Keyword: Structure
UnsafeTerm            : &lt;INITIAL, Generic                                             &gt;'unsafe'                                                                              : Token; // Keyword: Structure
VarTerm               : &lt;INITIAL, Generic                                             &gt;'var'                                                                                 : Token; // Keyword: Statement
DollarIdentifierTerm  : &lt;INITIAL, Generic                                             &gt;/\$[a-zA-Z_][0-9a-zA-Z_$]*/                                                           : Token;
IdentifierTerm        : &lt;INITIAL, Generic, EmbedHeader,                           Attr&gt;/(?:r#)?[a-zA-Z_][0-9a-zA-Z_$]*/                                                      : Token;
AnyTerm               : &lt;                              EmbedBody, EmbedBodyInner      &gt;/(?:[^{}\\]|\\[^{])+/                                                                 : Token;

// ----------------------------------------------------------------------------
// Token
// ----------------------------------------------------------------------------

Comments: [ CommentsTerm ];

StartToken: Comments;

StringLiteralToken: StringLiteralTerm: Token Comments;

ExponentToken  : ExponentTerm  : Token Comments;
FixedPointToken: FixedPointTerm: Token Comments;
BasedToken     : BasedTerm     : Token Comments;
BaseLessToken  : BaseLessTerm  : Token Comments;
AllBitToken    : AllBitTerm    : Token Comments;

AssignmentOperatorToken: AssignmentOperatorTerm: Token Comments;
DiamondOperatorToken   : DiamondOperatorTerm   : Token Comments;
Operator02Token        : Operator02Term        : Token Comments;
Operator03Token        : Operator03Term        : Token Comments;
Operator04Token        : Operator04Term        : Token Comments;
Operator05Token        : Operator05Term        : Token Comments;
Operator06Token        : Operator06Term        : Token Comments;
Operator07Token        : Operator07Term        : Token Comments;
Operator08Token        : Operator08Term        : Token Comments;
Operator09Token        : Operator09Term        : Token Comments;
Operator10Token        : Operator10Term        : Token Comments;
Operator11Token        : Operator11Term        : Token Comments;
Operator12Token        : Operator12Term        : Token Comments;
UnaryOperatorToken     : UnaryOperatorTerm     : Token Comments;

ColonToken           : ColonTerm           : Token Comments;
ColonColonLAngleToken: ColonColonLAngleTerm: Token Comments;
ColonColonToken      : ColonColonTerm      : Token Comments;
CommaToken           : CommaTerm           : Token Comments;
DotDotToken          : DotDotTerm          : Token Comments;
DotDotEquToken       : DotDotEquTerm       : Token Comments;
DotToken             : DotTerm             : Token Comments;
EquToken             : EquTerm             : Token Comments;
HashLBracketToken    : HashLBracketTerm    : Token Comments;
HashToken            : HashTerm            : Token Comments;
QuestionToken        : QuestionTerm        : Token Comments;
QuoteLBraceToken     : QuoteLBraceTerm     : Token Comments;
QuoteToken           : QuoteTerm           : Token Comments;
LAngleToken          : LAngleTerm          : Token Comments;
EmbedLBraceToken     : LBraceTerm          : Token         ;
EscapedLBraceToken   : EscapedLBraceTerm   : Token         ;
TripleLBraceToken    : TripleLBraceTerm    : Token         ;
LBraceToken          : LBraceTerm          : Token Comments;
LBracketToken        : LBracketTerm        : Token Comments;
LParenToken          : LParenTerm          : Token Comments;
LTMinusToken         : LTMinusTerm         : Token Comments;
MinusColonToken      : MinusColonTerm      : Token Comments;
MinusGTToken         : MinusGTTerm         : Token Comments;
PlusColonToken       : PlusColonTerm       : Token Comments;
RAngleToken          : RAngleTerm          : Token Comments;
EmbedRBraceToken     : RBraceTerm          : Token         ;
EscapedRBraceToken   : EscapedRBraceTerm   : Token         ;
TripleRBraceToken    : TripleRBraceTerm    : Token Comments;
RBraceToken          : RBraceTerm          : Token Comments;
RBracketToken        : RBracketTerm        : Token Comments;
RParenToken          : RParenTerm          : Token Comments;
SemicolonToken       : SemicolonTerm       : Token Comments;
StarToken            : StarTerm            : Token Comments;

AliasToken         : AliasTerm         : Token Comments;
AlwaysCombToken    : AlwaysCombTerm    : Token Comments;
AlwaysFfToken      : AlwaysFfTerm      : Token Comments;
AsToken            : AsTerm            : Token Comments;
AssignToken        : AssignTerm        : Token Comments;
BindToken          : BindTerm          : Token Comments;
BitToken           : BitTerm           : Token Comments;
BlockToken         : BlockTerm         : Token Comments;
BBoolToken         : BBoolTerm         : Token Comments;
LBoolToken         : LBoolTerm         : Token Comments;
CaseToken          : CaseTerm          : Token Comments;
ClockToken         : ClockTerm         : Token Comments;
ClockPosedgeToken  : ClockPosedgeTerm  : Token Comments;
ClockNegedgeToken  : ClockNegedgeTerm  : Token Comments;
ConnectToken       : ConnectTerm       : Token Comments;
ConstToken         : ConstTerm         : Token Comments;
ConverseToken      : ConverseTerm      : Token Comments;
DefaultToken       : DefaultTerm       : Token Comments;
ElseToken          : ElseTerm          : Token Comments;
EmbedToken         : EmbedTerm         : Token Comments;
EnumToken          : EnumTerm          : Token Comments;
F32Token           : F32Term           : Token Comments;
F64Token           : F64Term           : Token Comments;
FalseToken         : FalseTerm         : Token Comments;
FinalToken         : FinalTerm         : Token Comments;
ForToken           : ForTerm           : Token Comments;
FunctionToken      : FunctionTerm      : Token Comments;
I8Token            : I8Term            : Token Comments;
I16Token           : I16Term           : Token Comments;
I32Token           : I32Term           : Token Comments;
I64Token           : I64Term           : Token Comments;
IfResetToken       : IfResetTerm       : Token Comments;
IfToken            : IfTerm            : Token Comments;
ImportToken        : ImportTerm        : Token Comments;
IncludeToken       : IncludeTerm       : Token Comments;
InitialToken       : InitialTerm       : Token Comments;
InoutToken         : InoutTerm         : Token Comments;
InputToken         : InputTerm         : Token Comments;
InsideToken        : InsideTerm        : Token Comments;
InstToken          : InstTerm          : Token Comments;
InterfaceToken     : InterfaceTerm     : Token Comments;
InToken            : InTerm            : Token Comments;
LetToken           : LetTerm           : Token Comments;
LogicToken         : LogicTerm         : Token Comments;
LsbToken           : LsbTerm           : Token Comments;
ModportToken       : ModportTerm       : Token Comments;
ModuleToken        : ModuleTerm        : Token Comments;
MsbToken           : MsbTerm           : Token Comments;
OutputToken        : OutputTerm        : Token Comments;
OutsideToken       : OutsideTerm       : Token Comments;
PackageToken       : PackageTerm       : Token Comments;
ParamToken         : ParamTerm         : Token Comments;
ProtoToken         : ProtoTerm         : Token Comments;
PubToken           : PubTerm           : Token Comments;
RepeatToken        : RepeatTerm        : Token Comments;
ResetToken         : ResetTerm         : Token Comments;
ResetAsyncHighToken: ResetAsyncHighTerm: Token Comments;
ResetAsyncLowToken : ResetAsyncLowTerm : Token Comments;
ResetSyncHighToken : ResetSyncHighTerm : Token Comments;
ResetSyncLowToken  : ResetSyncLowTerm  : Token Comments;
ReturnToken        : ReturnTerm        : Token Comments;
RevToken           : RevTerm           : Token Comments;
BreakToken         : BreakTerm         : Token Comments;
SameToken          : SameTerm          : Token Comments;
SignedToken        : SignedTerm        : Token Comments;
StepToken          : StepTerm          : Token Comments;
StringToken        : StringTerm        : Token Comments;
StructToken        : StructTerm        : Token Comments;
SwitchToken        : SwitchTerm        : Token Comments;
TriToken           : TriTerm           : Token Comments;
TrueToken          : TrueTerm          : Token Comments;
TypeToken          : TypeTerm          : Token Comments;
U8Token            : U8Term            : Token Comments;
U16Token           : U16Term           : Token Comments;
U32Token           : U32Term           : Token Comments;
U64Token           : U64Term           : Token Comments;
UnionToken         : UnionTerm         : Token Comments;
UnsafeToken        : UnsafeTerm        : Token Comments;
VarToken           : VarTerm           : Token Comments;

DollarIdentifierToken: DollarIdentifierTerm: Token Comments;
IdentifierToken      : IdentifierTerm      : Token Comments;

AnyToken: AnyTerm: Token;

// ----------------------------------------------------------------------------
// VerylToken
// ----------------------------------------------------------------------------

// Start
Start: StartToken: VerylToken;

// StringLiteral
StringLiteral: StringLiteralToken: VerylToken;

// Number
Exponent  : ExponentToken  : VerylToken;
FixedPoint: FixedPointToken: VerylToken;
Based     : BasedToken     : VerylToken;
BaseLess  : BaseLessToken  : VerylToken;
AllBit    : AllBitToken    : VerylToken;

// Operator
AssignmentOperator: AssignmentOperatorToken: VerylToken;
DiamondOperator   : DiamondOperatorToken   : VerylToken;
Operator02        : Operator02Token        : VerylToken;
Operator03        : Operator03Token        : VerylToken;
Operator04        : Operator04Token        : VerylToken;
Operator05        : Operator05Token        : VerylToken;
Operator06        : Operator06Token        : VerylToken;
Operator07        : Operator07Token        : VerylToken;
Operator08        : Operator08Token        : VerylToken;
Operator09        : Operator09Token        : VerylToken;
Operator10        : Operator10Token        : VerylToken;
Operator11        : Operator11Token        : VerylToken;
Operator12        : Operator12Token        : VerylToken;
UnaryOperator     : UnaryOperatorToken     : VerylToken;

// Symbol
Colon           : ColonToken           : VerylToken;
ColonColonLAngle: ColonColonLAngleToken: VerylToken;
ColonColon      : ColonColonToken      : VerylToken;
Comma           : CommaToken           : VerylToken;
DotDot          : DotDotToken          : VerylToken;
DotDotEqu       : DotDotEquToken       : VerylToken;
Dot             : DotToken             : VerylToken;
Equ             : EquToken             : VerylToken;
HashLBracket    : HashLBracketToken    : VerylToken;
Hash            : HashToken            : VerylToken;
Question        : QuestionToken        : VerylToken;
QuoteLBrace     : QuoteLBraceToken     : VerylToken;
Quote           : QuoteToken           : VerylToken;
LAngle          : LAngleToken          : VerylToken;
EmbedLBrace     : EmbedLBraceToken     : VerylToken;
EscapedLBrace   : EscapedLBraceToken   : VerylToken;
TripleLBrace    : TripleLBraceToken    : VerylToken;
LBrace          : LBraceToken          : VerylToken;
LBracket        : LBracketToken        : VerylToken;
LParen          : LParenToken          : VerylToken;
LTMinus         : LTMinusToken         : VerylToken;
MinusColon      : MinusColonToken      : VerylToken;
MinusGT         : MinusGTToken         : VerylToken;
PlusColon       : PlusColonToken       : VerylToken;
RAngle          : RAngleToken          : VerylToken;
EmbedRBrace     : EmbedRBraceToken     : VerylToken;
EscapedRBrace   : EscapedRBraceToken   : VerylToken;
TripleRBrace    : TripleRBraceToken    : VerylToken;
RBrace          : RBraceToken          : VerylToken;
RBracket        : RBracketToken        : VerylToken;
RParen          : RParenToken          : VerylToken;
Semicolon       : SemicolonToken       : VerylToken;
Star            : StarToken            : VerylToken;

// Keyword
Alias         : AliasToken         : VerylToken;
AlwaysComb    : AlwaysCombToken    : VerylToken;
AlwaysFf      : AlwaysFfToken      : VerylToken;
As            : AsToken            : VerylToken;
Assign        : AssignToken        : VerylToken;
Bind          : BindToken          : VerylToken;
Bit           : BitToken           : VerylToken;
Block         : BlockToken         : VerylToken;
BBool         : BBoolToken         : VerylToken;
LBool         : LBoolToken         : VerylToken;
Break         : BreakToken         : VerylToken;
Case          : CaseToken          : VerylToken;
Clock         : ClockToken         : VerylToken;
ClockPosedge  : ClockPosedgeToken  : VerylToken;
ClockNegedge  : ClockNegedgeToken  : VerylToken;
Connect       : ConnectToken       : VerylToken;
Const         : ConstToken         : VerylToken;
Converse      : ConverseToken      : VerylToken;
Defaul        : DefaultToken       : VerylToken; // avoid to conflict with Rust's Default trait
Else          : ElseToken          : VerylToken;
Embed         : EmbedToken         : VerylToken;
Enum          : EnumToken          : VerylToken;
F32           : F32Token           : VerylToken;
F64           : F64Token           : VerylToken;
False         : FalseToken         : VerylToken;
Final         : FinalToken         : VerylToken;
For           : ForToken           : VerylToken;
Function      : FunctionToken      : VerylToken;
I8            : I8Token            : VerylToken;
I16           : I16Token           : VerylToken;
I32           : I32Token           : VerylToken;
I64           : I64Token           : VerylToken;
If            : IfToken            : VerylToken;
IfReset       : IfResetToken       : VerylToken;
Import        : ImportToken        : VerylToken;
In            : InToken            : VerylToken;
Include       : IncludeToken       : VerylToken;
Initial       : InitialToken       : VerylToken;
Inout         : InoutToken         : VerylToken;
Input         : InputToken         : VerylToken;
Inside        : InsideToken        : VerylToken;
Inst          : InstToken          : VerylToken;
Interface     : InterfaceToken     : VerylToken;
Let           : LetToken           : VerylToken;
Logic         : LogicToken         : VerylToken;
Lsb           : LsbToken           : VerylToken;
Modport       : ModportToken       : VerylToken;
Module        : ModuleToken        : VerylToken;
Msb           : MsbToken           : VerylToken;
Output        : OutputToken        : VerylToken;
Outside       : OutsideToken       : VerylToken;
Package       : PackageToken       : VerylToken;
Param         : ParamToken         : VerylToken;
Proto         : ProtoToken         : VerylToken;
Pub           : PubToken           : VerylToken;
Repeat        : RepeatToken        : VerylToken;
Reset         : ResetToken         : VerylToken;
ResetAsyncHigh: ResetAsyncHighToken: VerylToken;
ResetAsyncLow : ResetAsyncLowToken : VerylToken;
ResetSyncHigh : ResetSyncHighToken : VerylToken;
ResetSyncLow  : ResetSyncLowToken  : VerylToken;
Return        : ReturnToken        : VerylToken;
Rev           : RevToken           : VerylToken;
Same          : SameToken          : VerylToken;
Signed        : SignedToken        : VerylToken;
Step          : StepToken          : VerylToken;
Strin         : StringToken        : VerylToken; // avoid to conflict with Rust's String struct
Struct        : StructToken        : VerylToken;
Switch        : SwitchToken        : VerylToken;
Tri           : TriToken           : VerylToken;
True          : TrueToken          : VerylToken;
Type          : TypeToken          : VerylToken;
U8            : U8Token            : VerylToken;
U16           : U16Token           : VerylToken;
U32           : U32Token           : VerylToken;
U64           : U64Token           : VerylToken;
Union         : UnionToken         : VerylToken;
Unsafe        : UnsafeToken        : VerylToken;
Var           : VarToken           : VerylToken;

// Identifier
DollarIdentifier: DollarIdentifierToken: VerylToken;
Identifier      : IdentifierToken      : VerylToken;

Any: AnyToken: VerylToken;

// ----------------------------------------------------------------------------
// Number
// ----------------------------------------------------------------------------

Number: IntegralNumber
      | RealNumber
      ;

IntegralNumber: Based
              | BaseLess
              | AllBit
              ;

RealNumber: FixedPoint
          | Exponent
          ;

// ----------------------------------------------------------------------------
// Complex Identifier
// ----------------------------------------------------------------------------

HierarchicalIdentifier: Identifier { Select } { Dot Identifier { Select } };
ScopedIdentifier      : ( DollarIdentifier | Identifier [ WithGenericArgument ] ) { ColonColon Identifier [ WithGenericArgument ] };
ExpressionIdentifier  : ScopedIdentifier [ Width ] { Select } { Dot Identifier { Select } };
GenericArgIdentifier  : ScopedIdentifier { Dot Identifier };

// ----------------------------------------------------------------------------
// Expression
// ----------------------------------------------------------------------------

Expression  : IfExpression;
IfExpression: { If Expression Question Expression Colon } Expression01;
Expression01: Expression02 { Operator02 Expression02 };
Expression02: Expression03 { Operator03 Expression03 };
Expression03: Expression04 { Operator04 Expression04 };
Expression04: Expression05 { Operator05 Expression05 };
Expression05: Expression06 { Operator06 Expression06 };
Expression06: Expression07 { Operator07 Expression07 };
Expression07: Expression08 { Operator08 Expression08 };
Expression08: Expression09 { Operator09 Expression09 };
Expression09: Expression10 { Operator10 Expression10 };
Expression10: Expression11 { ( Operator11 | Star ) Expression11 };
Expression11: Expression12 { Operator12 Expression12 };
Expression12: Expression13 [ As CastingType ];
Expression13: { ( UnaryOperator | Operator10 | Operator06 | Operator04 | Operator05 ) } Factor;

Factor: Number
      | BooleanLiteral
      | IdentifierFactor
      | LParen Expression RParen
      | LBrace ConcatenationList RBrace
      | QuoteLBrace ArrayLiteralList RBrace
      | CaseExpression
      | SwitchExpression
      | StringLiteral
      | ( Msb | Lsb )
      | InsideExpression
      | OutsideExpression
      | TypeExpression
      | FactorTypeFactor
      ;

BooleanLiteral: True | False;

IdentifierFactor: ExpressionIdentifier [ FunctionCall | StructConstructor ];

FactorTypeFactor: { TypeModifier } FactorType;

FunctionCall: LParen [ ArgumentList ] RParen;

ArgumentList: ArgumentItem { Comma ArgumentItem } [ Comma ];

ArgumentItem: ArgumentExpression [ Colon Expression ];

ArgumentExpression: Expression;

StructConstructor: QuoteLBrace StructConstructorList [ DotDot Defaul LParen Expression RParen ] RBrace;

StructConstructorList: StructConstructorItem { Comma StructConstructorItem } [ Comma ];

StructConstructorItem: Identifier Colon Expression;

ConcatenationList: ConcatenationItem { Comma ConcatenationItem } [ Comma ];

ConcatenationItem: Expression [ Repeat Expression ];

ArrayLiteralList: ArrayLiteralItem { Comma ArrayLiteralItem } [ Comma ];

ArrayLiteralItem: ( Expression [ Repeat Expression ] | Defaul Colon Expression );

CaseExpression: Case Expression LBrace CaseCondition Colon Expression Comma { CaseCondition Colon Expression Comma } Defaul Colon Expression [ Comma ] RBrace;

SwitchExpression: Switch LBrace SwitchCondition Colon Expression Comma { SwitchCondition Colon Expression Comma } Defaul Colon Expression [ Comma ] RBrace;

TypeExpression: Type LParen Expression RParen;

InsideExpression: Inside Expression LBrace RangeList RBrace;

OutsideExpression: Outside Expression LBrace RangeList RBrace;

RangeList: RangeItem { Comma RangeItem } [ Comma ];

RangeItem: Range;

// ----------------------------------------------------------------------------
// Select / Width / Array / Range
// ----------------------------------------------------------------------------

Select: LBracket Expression [ SelectOperator Expression ] RBracket;

SelectOperator: Colon
              | PlusColon
              | MinusColon
              | Step
              ;

Width: LAngle Expression { Comma Expression } RAngle;

Array: LBracket Expression { Comma Expression } RBracket;

Range: Expression [ RangeOperator Expression ];

RangeOperator: DotDot
             | DotDotEqu
             ;

// ----------------------------------------------------------------------------
// ScalarType / ArrayType / CastingType
// ----------------------------------------------------------------------------

FixedType: U8 | U16 | U32 | U64 | I8 | I16| I32 | I64 | F32 | F64 | BBool | LBool | Strin;

VariableType: Clock
            | ClockPosedge
            | ClockNegedge
            | Reset
            | ResetAsyncHigh
            | ResetAsyncLow
            | ResetSyncHigh
            | ResetSyncLow
            | Logic
            | Bit;

UserDefinedType: ScopedIdentifier;

TypeModifier: Tri | Signed | Defaul;

FactorType: ( VariableType [ Width ] | FixedType );

ScalarType: { TypeModifier } ( UserDefinedType [ Width ] | FactorType );

ArrayType: ScalarType [ Array ];

CastingType: U8
           | U16
           | U32
           | U64
           | I8
           | I16
           | I32
           | I64
           | F32
           | F64
           | BBool
           | LBool
           | Clock
           | ClockPosedge
           | ClockNegedge
           | Reset
           | ResetAsyncHigh
           | ResetAsyncLow
           | ResetSyncHigh
           | ResetSyncLow
           | UserDefinedType
           | Based
           | BaseLess
           ;

// ----------------------------------------------------------------------------
// ClockDomain
// ----------------------------------------------------------------------------

ClockDomain: Quote Identifier;

// ----------------------------------------------------------------------------
// Statement
// ----------------------------------------------------------------------------

StatementBlock: LBrace { StatementBlockGroup } RBrace;

StatementBlockGroup: { Attribute } ( Block LBrace { StatementBlockGroup } RBrace | StatementBlockItem );

StatementBlockItem: VarDeclaration | LetStatement | ConstDeclaration | Statement | ConcatenationAssignment;

Statement: IdentifierStatement
         | IfStatement
         | IfResetStatement
         | ReturnStatement
         | BreakStatement
         | ForStatement
         | CaseStatement
         | SwitchStatement
         ;

LetStatement: Let Identifier Colon [ ClockDomain ] ArrayType Equ Expression Semicolon;

IdentifierStatement: ExpressionIdentifier ( FunctionCall | Assignment ) Semicolon;

ConcatenationAssignment: LBrace AssignConcatenationList RBrace Equ Expression Semicolon;

Assignment: ( Equ | AssignmentOperator | DiamondOperator ) Expression;

IfStatement: If Expression StatementBlock { Else If Expression StatementBlock } [ Else StatementBlock ];

IfResetStatement: IfReset StatementBlock { Else If Expression StatementBlock } [ Else StatementBlock ];

ReturnStatement: Return Expression Semicolon;

BreakStatement: Break Semicolon;

ForStatement: For Identifier Colon ScalarType In [ Rev ] Range [ Step AssignmentOperator Expression ] StatementBlock;

CaseStatement: Case Expression LBrace { CaseItem } RBrace;

CaseItem: ( CaseCondition | Defaul ) Colon ( Statement | StatementBlock );

CaseCondition: RangeItem { Comma RangeItem } ;

SwitchStatement: Switch LBrace { SwitchItem } RBrace;

SwitchItem: ( SwitchCondition | Defaul ) Colon ( Statement | StatementBlock );

SwitchCondition: Expression { Comma Expression } ;

// ----------------------------------------------------------------------------
// Attribute
// ----------------------------------------------------------------------------

Attribute: HashLBracket Identifier [ LParen AttributeList RParen ] RBracket ;

AttributeList: AttributeItem { Comma AttributeItem } [ Comma ];

AttributeItem: Identifier
             | StringLiteral
             ;

// ----------------------------------------------------------------------------
// Declaration
// ----------------------------------------------------------------------------

LetDeclaration: Let Identifier Colon [ ClockDomain ] ArrayType Equ Expression Semicolon;

VarDeclaration: Var Identifier Colon [ ClockDomain ] ArrayType Semicolon;

ConstDeclaration: Const Identifier Colon ( ArrayType | Type ) Equ Expression Semicolon;

TypeDefDeclaration: Type Identifier Equ ArrayType Semicolon;

AlwaysFfDeclaration: AlwaysFf [ AlwaysFfEventList ] StatementBlock;

AlwaysFfEventList: LParen AlwaysFfClock [ Comma AlwaysFfReset ] RParen;

AlwaysFfClock: HierarchicalIdentifier;

AlwaysFfReset: HierarchicalIdentifier;

AlwaysCombDeclaration: AlwaysComb StatementBlock;

AssignDeclaration: Assign AssignDestination Equ Expression Semicolon;

AssignDestination: HierarchicalIdentifier
                 | LBrace AssignConcatenationList RBrace;

AssignConcatenationList: AssignConcatenationItem { Comma AssignConcatenationItem } [ Comma ];

AssignConcatenationItem: HierarchicalIdentifier;

ConnectDeclaration: Connect HierarchicalIdentifier DiamondOperator Expression Semicolon;

ModportDeclaration: Modport Identifier LBrace [ ModportList ] [ DotDot ModportDefault ] RBrace;

ModportList: ModportGroup { Comma ModportGroup } [ Comma ];

ModportGroup: { Attribute } ( LBrace ModportList RBrace | ModportItem );

ModportItem: Identifier Colon Direction;

ModportDefault: Input
              | Output
              | Same LParen Identifier RParen
              | Converse LParen Identifier RParen;

EnumDeclaration: Enum Identifier [ Colon ScalarType ] LBrace EnumList RBrace;

EnumList: EnumGroup { Comma EnumGroup } [ Comma ];

EnumGroup: { Attribute } ( LBrace EnumList RBrace | EnumItem );

EnumItem: Identifier [ Equ Expression ];

StructUnion: Struct | Union;

StructUnionDeclaration: StructUnion Identifier [ WithGenericParameter ] LBrace StructUnionList RBrace;

StructUnionList: StructUnionGroup { Comma StructUnionGroup } [ Comma ];

StructUnionGroup: { Attribute } ( LBrace StructUnionList RBrace | StructUnionItem );

StructUnionItem: Identifier Colon ScalarType;

InitialDeclaration: Initial StatementBlock;

FinalDeclaration: Final StatementBlock;

// ----------------------------------------------------------------------------
// InstDeclaration/BindDeclaration
// ----------------------------------------------------------------------------

InstDeclaration: Inst ComponentInstantiation Semicolon;

BindDeclaration: Bind ScopedIdentifier LTMinus ComponentInstantiation Semicolon;

ComponentInstantiation: Identifier Colon [ ClockDomain ] ScopedIdentifier [ Array ] [ InstParameter ] [ InstPort ];

InstParameter: Hash LParen [ InstParameterList ] RParen;

InstParameterList: InstParameterGroup { Comma InstParameterGroup } [ Comma ];

InstParameterGroup: { Attribute } ( LBrace InstParameterList RBrace | InstParameterItem );

InstParameterItem: Identifier [ Colon Expression ];

InstPort: LParen [ InstPortList ] RParen;

InstPortList: InstPortGroup { Comma InstPortGroup } [ Comma ];

InstPortGroup: { Attribute } ( LBrace InstPortList RBrace | InstPortItem );

InstPortItem: Identifier [ Colon Expression ];

// ----------------------------------------------------------------------------
// WithParameter
// ----------------------------------------------------------------------------

WithParameter: Hash LParen [ WithParameterList ] RParen;

WithParameterList: WithParameterGroup { Comma WithParameterGroup } [ Comma ];

WithParameterGroup: { Attribute } ( LBrace WithParameterList RBrace | WithParameterItem );

WithParameterItem: ( Param | Const ) Identifier Colon ( ArrayType | Type ) [ Equ Expression ];

// ----------------------------------------------------------------------------
// WithGenericParameter
// ----------------------------------------------------------------------------

GenericBound: Type
            | Inst ScopedIdentifier
            | GenericProtoBound;

WithGenericParameter: ColonColonLAngle WithGenericParameterList RAngle;

WithGenericParameterList: WithGenericParameterItem { Comma WithGenericParameterItem } [ Comma ];

WithGenericParameterItem: Identifier Colon GenericBound [ Equ WithGenericArgumentItem ];

GenericProtoBound: ScopedIdentifier | FixedType;

// ----------------------------------------------------------------------------
// WithGenericArgument
// ----------------------------------------------------------------------------

WithGenericArgument: ColonColonLAngle [ WithGenericArgumentList ] RAngle;

WithGenericArgumentList: WithGenericArgumentItem { Comma WithGenericArgumentItem } [ Comma ];

WithGenericArgumentItem: GenericArgIdentifier
                       | FixedType
                       | Number
                       | BooleanLiteral
                       ;

// ----------------------------------------------------------------------------
// PortDeclaration
// ----------------------------------------------------------------------------

PortDeclaration: LParen [ PortDeclarationList ] RParen;

PortDeclarationList: PortDeclarationGroup { Comma PortDeclarationGroup } [ Comma ];

PortDeclarationGroup: { Attribute } ( LBrace PortDeclarationList RBrace | PortDeclarationItem );

PortDeclarationItem: Identifier Colon ( PortTypeConcrete | PortTypeAbstract );

PortTypeConcrete: Direction [ ClockDomain ] ArrayType [ Equ PortDefaultValue ];

PortDefaultValue: Expression;

PortTypeAbstract: [ ClockDomain ] Interface [ ColonColon Identifier ] [ Array ];

Direction: Input
         | Output
         | Inout
         | Modport
         | Import
         ;

// ----------------------------------------------------------------------------
// Function
// ----------------------------------------------------------------------------

FunctionDeclaration: Function Identifier [ WithGenericParameter ] [ PortDeclaration ] [ MinusGT ScalarType ] StatementBlock;

// ----------------------------------------------------------------------------
// Import
// ----------------------------------------------------------------------------

ImportDeclaration: Import ScopedIdentifier [ ColonColon Star ] Semicolon;

// ----------------------------------------------------------------------------
// Unsafe
// ----------------------------------------------------------------------------

UnsafeBlock: Unsafe LParen Identifier RParen LBrace { GenerateGroup } RBrace;

// ----------------------------------------------------------------------------
// Module/Interface
// ----------------------------------------------------------------------------

ModuleDeclaration: Module Identifier [ WithGenericParameter ] [ For ScopedIdentifier ] [ WithParameter ] [ PortDeclaration ] LBrace { ModuleGroup } RBrace;

ModuleGroup: { Attribute } ( LBrace { ModuleGroup } RBrace | ModuleItem );

ModuleItem: GenerateItem;

InterfaceDeclaration: Interface Identifier [ WithGenericParameter ] [ For ScopedIdentifier ] [ WithParameter ] LBrace { InterfaceGroup } RBrace;

InterfaceGroup: { Attribute } ( LBrace { InterfaceGroup } RBrace | InterfaceItem );

InterfaceItem: GenerateItem | ModportDeclaration;

GenerateIfDeclaration: If Expression GenerateNamedBlock { Else If Expression GenerateOptionalNamedBlock } [ Else GenerateOptionalNamedBlock ];

GenerateForDeclaration: For Identifier In [ Rev ] Range [ Step AssignmentOperator Expression ] GenerateNamedBlock;

GenerateBlockDeclaration: GenerateNamedBlock;

GenerateNamedBlock: Colon Identifier LBrace { GenerateGroup } RBrace;

GenerateOptionalNamedBlock: [ Colon Identifier ] LBrace { GenerateGroup } RBrace;

GenerateGroup: { Attribute } ( LBrace { GenerateGroup } RBrace | GenerateItem );

GenerateItem: LetDeclaration
            | VarDeclaration
            | InstDeclaration
            | BindDeclaration
            | ConstDeclaration
            | AlwaysFfDeclaration
            | AlwaysCombDeclaration
            | AssignDeclaration
            | ConnectDeclaration
            | FunctionDeclaration
            | GenerateIfDeclaration
            | GenerateForDeclaration
            | GenerateBlockDeclaration
            | TypeDefDeclaration
            | EnumDeclaration
            | StructUnionDeclaration
            | ImportDeclaration
            | AliasDeclaration
            | InitialDeclaration
            | FinalDeclaration
            | UnsafeBlock
            | EmbedDeclaration
            ;

// ----------------------------------------------------------------------------
// Package
// ----------------------------------------------------------------------------

PackageDeclaration: Package Identifier [ WithGenericParameter ] [ For ScopedIdentifier ] LBrace { PackageGroup } RBrace;

PackageGroup: { Attribute } ( LBrace { PackageGroup } RBrace | PackageItem );

PackageItem: ConstDeclaration
           | TypeDefDeclaration
           | EnumDeclaration
           | StructUnionDeclaration
           | FunctionDeclaration
           | ImportDeclaration
           | AliasDeclaration
           | EmbedDeclaration
           ;

// ----------------------------------------------------------------------------
// Alias
// ----------------------------------------------------------------------------

AliasDeclaration: Alias ( Module | Interface | Package ) Identifier Equ ScopedIdentifier Semicolon;

// ----------------------------------------------------------------------------
// Proto
// ----------------------------------------------------------------------------

ProtoDeclaration: Proto ( ProtoModuleDeclaration | ProtoInterfaceDeclaration | ProtoPackageDeclaration );

ProtoModuleDeclaration: Module Identifier [ WithParameter ] [ PortDeclaration ] Semicolon;

ProtoInterfaceDeclaration: Interface Identifier [ WithParameter ] LBrace { ProtoInterfaceItem } RBrace;

ProtoInterfaceItem: VarDeclaration
                  | ProtoConstDeclaration
                  | ProtoFunctionDeclaration
                  | ProtoTypeDefDeclaration
                  | ProtoAliasDeclaration
                  | ModportDeclaration
                  | ImportDeclaration
                  ;

ProtoPackageDeclaration: Package Identifier LBrace { ProtoPacakgeItem } RBrace;

ProtoPacakgeItem: ProtoConstDeclaration
                | ProtoTypeDefDeclaration
                | EnumDeclaration
                | StructUnionDeclaration
                | ProtoFunctionDeclaration
                | ProtoAliasDeclaration
                | ImportDeclaration
                ;

ProtoConstDeclaration: Const Identifier Colon ( ArrayType | Type ) Semicolon;

ProtoTypeDefDeclaration: Type Identifier [ Equ ArrayType ] Semicolon;

ProtoFunctionDeclaration: Function Identifier [ WithGenericParameter ] [ PortDeclaration ] [ MinusGT ScalarType ] Semicolon;

ProtoAliasDeclaration: Alias ( Module | Interface | Package ) Identifier Colon ScopedIdentifier Semicolon;

// ----------------------------------------------------------------------------
// Embed
// ----------------------------------------------------------------------------

EmbedDeclaration: Embed LParen Identifier RParen Identifier EmbedContent;

EmbedContent: TripleLBrace { EmbedItem } TripleRBrace;

EmbedScopedIdentifier: EscapedLBrace ScopedIdentifier EscapedRBrace;

EmbedItem: EmbedLBrace { EmbedItem } EmbedRBrace
         | EmbedScopedIdentifier
         | Any;

// ----------------------------------------------------------------------------
// Include
// ----------------------------------------------------------------------------

IncludeDeclaration: Include LParen Identifier Comma StringLiteral RParen Semicolon;

// ----------------------------------------------------------------------------
// Description
// ----------------------------------------------------------------------------

DescriptionGroup: { Attribute } ( LBrace { DescriptionGroup } RBrace | DescriptionItem );

DescriptionItem: [ Pub ] PublicDescriptionItem
               | ImportDeclaration
               | BindDeclaration
               | EmbedDeclaration
               | IncludeDeclaration
               ;

PublicDescriptionItem: ModuleDeclaration
                     | InterfaceDeclaration
                     | PackageDeclaration
                     | AliasDeclaration
                     | ProtoDeclaration
                     ;

// ----------------------------------------------------------------------------
// SourceCode
// ----------------------------------------------------------------------------

Veryl: Start { DescriptionGroup };
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="セマンティックエラー"><a class="header" href="#セマンティックエラー">セマンティックエラー</a></h1>
<h2 id="duplicated_identifier"><a class="header" href="#duplicated_identifier">duplicated_identifier</a></h2>
<h2 id="invalid_allow"><a class="header" href="#invalid_allow">invalid_allow</a></h2>
<h2 id="invalid_direction"><a class="header" href="#invalid_direction">invalid_direction</a></h2>
<h2 id="invalid_identifier"><a class="header" href="#invalid_identifier">invalid_identifier</a></h2>
<h2 id="invalid_lsb"><a class="header" href="#invalid_lsb">invalid_lsb</a></h2>
<h2 id="invalid_msb"><a class="header" href="#invalid_msb">invalid_msb</a></h2>
<h2 id="invalid_number_character"><a class="header" href="#invalid_number_character">invalid_number_character</a></h2>
<h2 id="invalid_statement"><a class="header" href="#invalid_statement">invalid_statement</a></h2>
<h2 id="invalid_system_function"><a class="header" href="#invalid_system_function">invalid_system_function</a></h2>
<h2 id="invalid_type_declaration"><a class="header" href="#invalid_type_declaration">invalid_type_declaration</a></h2>
<p>このエラーは <code>struct</code>、<code>enum</code>、<code>union</code>のデータ型がインターフェース宣言内で定義されたことを示します。</p>
<h2 id="mismatch_arity"><a class="header" href="#mismatch_arity">mismatch_arity</a></h2>
<h2 id="mismatch_attribute_args"><a class="header" href="#mismatch_attribute_args">mismatch_attribute_args</a></h2>
<h2 id="mismatch_type"><a class="header" href="#mismatch_type">mismatch_type</a></h2>
<h2 id="missing_if_reset"><a class="header" href="#missing_if_reset">missing_if_reset</a></h2>
<h2 id="missing_port"><a class="header" href="#missing_port">missing_port</a></h2>
<h2 id="missing_reset_signal"><a class="header" href="#missing_reset_signal">missing_reset_signal</a></h2>
<h2 id="missing_reset_statement"><a class="header" href="#missing_reset_statement">missing_reset_statement</a></h2>
<h2 id="too_large_enum_variant"><a class="header" href="#too_large_enum_variant">too_large_enum_variant</a></h2>
<h2 id="too_large_number"><a class="header" href="#too_large_number">too_large_number</a></h2>
<h2 id="too_much_enum_variant"><a class="header" href="#too_much_enum_variant">too_much_enum_variant</a></h2>
<h2 id="undefined_identifier"><a class="header" href="#undefined_identifier">undefined_identifier</a></h2>
<h2 id="unknown_attribute"><a class="header" href="#unknown_attribute">unknown_attribute</a></h2>
<h2 id="unknown_member"><a class="header" href="#unknown_member">unknown_member</a></h2>
<h2 id="unknown_msb"><a class="header" href="#unknown_msb">unknown_msb</a></h2>
<h2 id="unknown_port"><a class="header" href="#unknown_port">unknown_port</a></h2>
<h2 id="unused_variable"><a class="header" href="#unused_variable">unused_variable</a></h2>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>

        <script src="ace.js"></script>
        <script src="editor.js"></script>
        <script src="mode-rust.js"></script>
        <script src="theme-dawn.js"></script>
        <script src="theme-tomorrow_night.js"></script>

        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>
        <script type="module">
            import init, {build, format} from "https://doc.veryl-lang.org/nightly/playground/pkg/veryl_wasm.js";
            init().then(() => {});
            window.build = build;
        </script>

        <!-- Custom JS scripts -->
        <script src="mode-veryl.js"></script>
        <script src="editor.js"></script>
        <script src="theme/language-picker.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
